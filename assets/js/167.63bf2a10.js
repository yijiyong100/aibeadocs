(window.webpackJsonp=window.webpackJsonp||[]).push([[167],{683:function(t,s,a){"use strict";a.r(s);var n=a(53),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("本文主要是介绍 常用搜索算法-A*查找 。")])]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#a-搜索算法"}},[t._v("A*搜索算法")]),a("ul",[a("li",[a("a",{attrs:{href:"#方法一、仅采用积累距离"}},[t._v("方法一、仅采用积累距离")])]),a("li",[a("a",{attrs:{href:"#方法二、启发式距离-扩展列表"}},[t._v("方法二、启发式距离 + 扩展列表")])])])]),a("li",[a("a",{attrs:{href:"#参考文章"}},[t._v("参考文章")])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"a-搜索算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#a-搜索算法"}},[t._v("#")]),t._v(" A*搜索算法")]),t._v(" "),a("p",[t._v("A"),a("em",[t._v("搜索算法是最短路径问题中另一个非常经典的算法。A")]),t._v("算法常用于游戏中的NPC的移动计算，或网络游戏的BOT的移动计算上。")]),t._v(" "),a("p",[t._v("A*搜寻算法，俗称A星算法，作为启发式搜索算法中的一种，这是一种在图形平面上，有多个节点的路径，求出最低通过成本的算法。常用于游戏中的NPC的移动计算，或线上游戏的BOT的移动计算上。该算法像Dijkstra算法一样，可以找到一条最短路径；也像BFS一样，进行启发式的搜索。")]),t._v(" "),a("p",[t._v("该算法综合了Best-First Search和Dijkstra算法的优点："),a("strong",[t._v("在进行启发式搜索提高算法效率的同时，可以保证找到一条最优路径（基于评估函数）。")])]),t._v(" "),a("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/algorithm/search/comm8/1187314-20180317181821691-617556157.png"),alt:"wxmp"}}),t._v(" "),a("p",[t._v("下面举例说明这个算法的过程，举例用的网络如下，从S - > G：")]),t._v(" "),a("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/algorithm/search/comm8/1187314-20180317182610104-1625335187.png"),alt:"wxmp"}}),t._v(" "),a("h3",{attrs:{id:"方法一、仅采用积累距离"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法一、仅采用积累距离"}},[t._v("#")]),t._v(" 方法一、仅采用积累距离")]),t._v(" "),a("p",[a("strong",[t._v("算法流程：")])]),t._v(" "),a("blockquote",[a("p",[t._v("​               Get the end，break")]),t._v(" "),a("p",[t._v("|")]),t._v(" "),a("p",[t._v("Initial Queue --\x3e Test First Path --\x3e Extend First Path ， sorted by ACC")]),t._v(" "),a("p",[t._v("|——————————|")])]),t._v(" "),a("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/algorithm/search/comm8/1187314-20180317183714644-892267073.png"),alt:"wxmp"}}),t._v(" "),a("p",[t._v("由于我每次都扩展的最小的积累距离值，所以第取出G的时候，就是G为最短路确定的时候，因为任何其他的路都比S - ›G长，而且日后也不可能更短。")]),t._v(" "),a("p",[t._v("其实这就是Dijkstra算法。当然在这里，我做了很多无效的extend，如果维护一个extend表，那么效率将会有很大的提升。")]),t._v(" "),a("h3",{attrs:{id:"方法二、启发式距离-扩展列表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法二、启发式距离-扩展列表"}},[t._v("#")]),t._v(" 方法二、启发式距离 + 扩展列表")]),t._v(" "),a("p",[t._v("上面的Dijkstra方法不好的地方是很明显的，这种方法没有方向性，是一种发散式的搜索，事实上，运行一遍Dijkstra可以将源点到其他所有点的最短路径求出来。")]),t._v(" "),a("p",[t._v("然而，在很多问题中，我们并不需要源点到其他结点的距离信息，我们只关系源点到目的地的最短路径，这时候就可以使用启发式的距离，来让路径的生成变得有方向性。")]),t._v(" "),a("p",[t._v("具体做法就是将上面的选择过程中积累长度变成积累长度 + 启发式距离。")]),t._v(" "),a("p",[t._v("在找到一条路径后还需向下探查，直到其他路都绝无可能为止。")]),t._v(" "),a("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/algorithm/search/comm8/1187314-20180317185250470-1524723308.png"),alt:"wxmp"}}),t._v(" "),a("p",[t._v("另外，这里加上了扩展列表，也就是已经扩展过的不会再继续扩展，这就是A*算法的思路。")]),t._v(" "),a("p",[t._v("A* = 分支限界 + 扩展列表 + 可容许启发式路径。")]),t._v(" "),a("div",{staticClass:"language-py extra-class"},[a("pre",{pre:!0,attrs:{class:"language-py"}},[a("code",[t._v("function A"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("start"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("goal"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    closedset "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" the empty "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("set")]),t._v("                 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("已经被估算的节点集合\n    openset "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("set")]),t._v(" containing the initial node "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("将要被估算的节点集合，初始只包含start\n    came_from "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" empty "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("map")]),t._v("\n    g_score"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("start"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("                        "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("g"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    h_score"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("start"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" heuristic_estimate_of_distance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("start"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" goal"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("通过估计函数 估计h"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("start"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    f_score"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("start"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" h_score"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("start"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("            "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("f"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("h"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("g"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("，由于g"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("，所以省略\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" openset "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("is")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("not")]),t._v(" empty                 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("当将被估算的节点存在时，执行循环\n        x "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" the node "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" openset having the lowest f_score"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" value   "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("在将被估计的集合中找到f"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("最小的节点\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" goal            "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("若x为终点，执行\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" reconstruct_path"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("came_from"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("goal"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("返回到x的最佳路径\n        remove x "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" openset      "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("将x节点从将被估算的节点中删除\n        add x to closedset      "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("将x节点插入已经被估算的节点\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" each y "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" neighbor_nodes"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("循环遍历与x相邻节点\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" y "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" closedset           "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("若y已被估值，跳过\n                "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("continue")]),t._v("\n            tentative_g_score "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" g_score"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" dist_between"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("从起点到节点y的距离\n \n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" y "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("not")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" openset          "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("若y不是将被估算的节点\n                add y to openset         "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("将y插入将被估算的节点中\n                tentative_is_better "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" true     "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("暂时判断为更好\n            elseif tentative_g_score "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" g_score"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("         "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("如果起点到y的距离小于y的实际距离\n                tentative_is_better "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" true         "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("暂时判断为更好\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v("\n                tentative_is_better "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" false           "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("否则判断为更差\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" tentative_is_better "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" true            "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("如果判断为更好\n                came_from"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" x                  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("将y设为x的子节点\n                g_score"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" tentative_g_score    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("更新y到原点的距离\n                h_score"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" heuristic_estimate_of_distance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" goal"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v("估计y到终点的距离\n                f_score"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" g_score"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" h_score"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" failure\n \nfunction reconstruct_path"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("came_from"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("current_node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" came_from"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("current_node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("is")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("set")]),t._v("\n        p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" reconstruct_path"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("came_from"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("came_from"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("current_node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" current_node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" current_node\n")])])]),a("h2",{attrs:{id:"参考文章"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章")]),t._v(" "),a("ul",[a("li",[t._v("http://www.cnblogs.com/maybe2030/")]),t._v(" "),a("li",[t._v("https://www.cnblogs.com/magic-sea/tag/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/")]),t._v(" "),a("li",[t._v("https://www.cnblogs.com/hyserendipity/p/8591949.html")])])])}),[],!1,null,null,null);s.default=e.exports}}]);