(window.webpackJsonp=window.webpackJsonp||[]).push([[192],{708:function(a,v,t){"use strict";t.r(v);var _=t(53),r=Object(_.a)({},(function(){var a=this,v=a.$createElement,t=a._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),t("p",[a._v("本文主要是介绍 五种基本算法思想总结 。")])]),a._v(" "),t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#算法思想介绍和总结-分治-贪心-djs-动态分配-dp-回溯-万能"}},[a._v("算法思想介绍和总结（分治），贪心（DJS）动态分配（dp）回溯（万能）")])]),t("li",[t("a",{attrs:{href:"#一、算法思想"}},[a._v("一、算法思想")]),t("ul",[t("li",[t("a",{attrs:{href:"#一-分治法-divide-and-conquer-method"}},[a._v("（一）分治法（divide and conquer method）")])]),t("li",[t("a",{attrs:{href:"#二-动态规划法-dynamic-programing-method"}},[a._v("（二）动态规划法（dynamic programing method）")])]),t("li",[t("a",{attrs:{href:"#三-贪心法-greedy-method"}},[a._v("（三）贪心法（greedy method）")])]),t("li",[t("a",{attrs:{href:"#四-回溯法-back-track-method"}},[a._v("（四）回溯法（back track method）")])])])]),t("li",[t("a",{attrs:{href:"#二、算法差异"}},[a._v("二、算法差异")]),t("ul",[t("li",[t("a",{attrs:{href:"#一-分治法和动态规划法的区别"}},[a._v("（一）分治法和动态规划法的区别")])]),t("li",[t("a",{attrs:{href:"#二-动态规划法和贪心法的区别"}},[a._v("（二）动态规划法和贪心法的区别")])])])]),t("li",[t("a",{attrs:{href:"#三、适用情况"}},[a._v("三、适用情况")]),t("ul",[t("li",[t("a",{attrs:{href:"#一-分治法"}},[a._v("(一)分治法")])]),t("li",[t("a",{attrs:{href:"#二-动态规划法"}},[a._v("(二)动态规划法")])]),t("li",[t("a",{attrs:{href:"#三-贪心法"}},[a._v("(三)贪心法")])]),t("li",[t("a",{attrs:{href:"#四-回溯法"}},[a._v("(四)回溯法")])])])]),t("li",[t("a",{attrs:{href:"#分治算法"}},[a._v("分治算法")]),t("ul",[t("li",[t("a",{attrs:{href:"#一、基本概念"}},[a._v("一、基本概念")])]),t("li",[t("a",{attrs:{href:"#二、基本思想及策略"}},[a._v("二、基本思想及策略")])]),t("li",[t("a",{attrs:{href:"#可使用分治法求解的一些经典问题"}},[a._v("可使用分治法求解的一些经典问题")])]),t("li",[t("a",{attrs:{href:"#依据分治法设计程序时的思维过程"}},[a._v("依据分治法设计程序时的思维过程")])])])]),t("li",[t("a",{attrs:{href:"#动态规划算法"}},[a._v("动态规划算法")]),t("ul",[t("li",[t("a",{attrs:{href:"#一、基本概念"}},[a._v("一、基本概念")])]),t("li",[t("a",{attrs:{href:"#二、基本思想与策略"}},[a._v("二、基本思想与策略")])]),t("li",[t("a",{attrs:{href:"#三、适用的情况"}},[a._v("三、适用的情况")])]),t("li",[t("a",{attrs:{href:"#四、求解的基本步骤"}},[a._v("四、求解的基本步骤")])]),t("li",[t("a",{attrs:{href:"#算法实现的说明"}},[a._v("算法实现的说明")])]),t("li",[t("a",{attrs:{href:"#动规解题的一般思路"}},[a._v("动规解题的一般思路")])]),t("li",[t("a",{attrs:{href:"#数字三角形的状态转移方程"}},[a._v("数字三角形的状态转移方程:")])])])]),t("li",[t("a",{attrs:{href:"#参考文章"}},[a._v("参考文章")])])])]),t("p"),a._v(" "),t("h2",{attrs:{id:"算法思想介绍和总结-分治-贪心-djs-动态分配-dp-回溯-万能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法思想介绍和总结-分治-贪心-djs-动态分配-dp-回溯-万能"}},[a._v("#")]),a._v(" 算法思想介绍和总结（分治），贪心（DJS）动态分配（dp）回溯（万能）")]),a._v(" "),t("p",[a._v("不管是动态规划，还是回溯都是在可选择 条件固定时，进行选择 ，都会用到递归调用。")]),a._v(" "),t("p",[a._v("不同的是：")]),a._v(" "),t("p",[a._v("贪心最好理解，从头开始找最优结果一直到最后。（一般for循环就可以）")]),a._v(" "),t("p",[a._v("分治思想就是完全的找局部最优解，然后综上所述。（递归调用进行区域划分）")]),a._v(" "),t("p",[a._v("动态规划一般见问题从 结束点出发，找最小范围的最优解，然后迭代到初始位置。（爬楼梯问题：找出最后一步最优解，递归到第一步）")]),a._v(" "),t("p",[a._v("回溯的话就是从头开始进行试探，在过程中可能会有阻挡，因此进行试探找出出路。（迷宫求解）")]),a._v(" "),t("p",[a._v("由此可见，解决问题是影响条件不断增多，难度不断加深，因此回溯有通解之称，但是相对复杂，时间复杂度要大，因此应该合适的使用算法思想，以达到最优。")]),a._v(" "),t("h2",{attrs:{id:"一、算法思想"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、算法思想"}},[a._v("#")]),a._v(" 一、算法思想")]),a._v(" "),t("h3",{attrs:{id:"一-分治法-divide-and-conquer-method"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一-分治法-divide-and-conquer-method"}},[a._v("#")]),a._v(" （一）分治法（divide and conquer method）")]),a._v(" "),t("p",[a._v("是将待求解的原问题划分成k个较小规模的子问题，对这k个子问题分别求解。如果子问题的规模仍然不够小，则再将每个子问题划分为k个规模更小的子问题，如此分解下去，直到问题规模足够小，很容易求出其解为止（子问题求解思路一致），再将子问题的解合并为一个更大规模的问题的解，自底向上逐步求出原问题的解。")]),a._v(" "),t("h3",{attrs:{id:"二-动态规划法-dynamic-programing-method"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二-动态规划法-dynamic-programing-method"}},[a._v("#")]),a._v(" （二）动态规划法（dynamic programing method）")]),a._v(" "),t("p",[a._v("是将待求解问题分解成若干个相互重叠的子问题，每个子问题对应决策过程的一个阶段，一般来说，子问题的重叠关系表现在对给定问题求解的递推关系（也就是动态规划函数）中，将子问题的解求解一次并填入表中，当需要再次求解此子问题时，可以通过查表获得该子问题的解而不用再次求解，从而避免了大量重复计算。")]),a._v(" "),t("h3",{attrs:{id:"三-贪心法-greedy-method"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三-贪心法-greedy-method"}},[a._v("#")]),a._v(" （三）贪心法（greedy method）")]),a._v(" "),t("p",[a._v("贪心法在解决问题的策略上目光短浅，只根据当前已有的信息就做出选择，而且一旦做出了选择，不管将来有什么结果，这个选择都不会改变。换言之，贪心法并不是从整体最优考虑，它所做出的选择只是在某种意义上的局部最优。这种局部最优选择并不总能获得整体最优解（Optimal Solution），但通常能获得近似最优解（Near-Optimal Solution）。")]),a._v(" "),t("h3",{attrs:{id:"四-回溯法-back-track-method"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四-回溯法-back-track-method"}},[a._v("#")]),a._v(" （四）回溯法（back track method）")]),a._v(" "),t("p",[a._v("回溯法就是一种有组织的系统化搜索技术，可以看作是蛮力法穷举搜索的改进。回溯法每次只构建可能解的一部分，然后评估这个部分解，如果这个部分有可能导致一个完全解，对其进一步搜索，否则，就不必继续构造这部分的解了，回溯法常常可以避免搜索所有可能的解，所以，它往往比满立法效率更高，适用于求解组合数组较大的问题。")]),a._v(" "),t("h2",{attrs:{id:"二、算法差异"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、算法差异"}},[a._v("#")]),a._v(" 二、算法差异")]),a._v(" "),t("h3",{attrs:{id:"一-分治法和动态规划法的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一-分治法和动态规划法的区别"}},[a._v("#")]),a._v(" （一）分治法和动态规划法的区别")]),a._v(" "),t("p",[a._v("共同点：二者都要求原问题具有最优子结构性质，都将原问题分成若干个子问题，然后将子问题的解合并，形成原问题的解。")]),a._v(" "),t("p",[a._v("不同点：动态规划法是将待求解问题分解成若干个相互重叠的子问题，而分治法是分解成若干个互不相交的子问题。利用分治法求解，这些子问题的重叠部分被重复计算多次。而动态规划法将每个子问题只求解一次并讲其保存在一个表格中，当需要再次求解此子问题时，只是简单地通过查表获得该子问题的解，从而避免了大量的重复计算。")]),a._v(" "),t("h3",{attrs:{id:"二-动态规划法和贪心法的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二-动态规划法和贪心法的区别"}},[a._v("#")]),a._v(" （二）动态规划法和贪心法的区别")]),a._v(" "),t("p",[a._v("共同点：贪心算法和动态规划算法都要求问题具有最优子结构性质。")]),a._v(" "),t("p",[a._v("不同点：动态规划法用到之前的最优解，贪心则不是，贪心无法解决动态规划的问题，但是动态规划能解决贪心的问题。虽然能够应用贪心算法一定能够应用动态规划法，但是一般来说，贪心算法的效率高于动态规划法，因而还是应用贪心算法。动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行，以迭代的方式作出相继的贪心选择，每做一次贪心选择就将所求问题简化为规模更小的子问题。")]),a._v(" "),t("h2",{attrs:{id:"三、适用情况"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、适用情况"}},[a._v("#")]),a._v(" 三、适用情况")]),a._v(" "),t("h3",{attrs:{id:"一-分治法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一-分治法"}},[a._v("#")]),a._v(" (一)分治法")]),a._v(" "),t("p",[a._v("适用特征：该问题的规模缩小到一定的程度就可以容易地解决；可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质；利用该问题分解出的子问题的解可以合并为该问题的解；所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。")]),a._v(" "),t("p",[a._v("典型代表：二分搜索、棋盘覆盖、合并排序、最接近点对问题、循环赛日程表、汉诺塔......")]),a._v(" "),t("h3",{attrs:{id:"二-动态规划法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二-动态规划法"}},[a._v("#")]),a._v(" (二)动态规划法")]),a._v(" "),t("p",[a._v("适用特征：该问题问题的最优解所包含的子问题的解也是最优的，即满足最优化原理；某状态以后的过程不会影响以前的状态，只与当前状态有关；子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。")]),a._v(" "),t("p",[a._v("典型代表：最长公共子序列、最优二叉查找树、近似串匹配问题......")]),a._v(" "),t("h3",{attrs:{id:"三-贪心法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三-贪心法"}},[a._v("#")]),a._v(" (三)贪心法")]),a._v(" "),t("p",[a._v("适用特征：该问题局部最优策略能导致产生全局最优解（贪心算法适用的情况很少）。")]),a._v(" "),t("p",[a._v("典型代表：TSP问题（最近邻点）、TSP问题（最短链接）、图着色、背包问题、多极度调度问题......")]),a._v(" "),t("h3",{attrs:{id:"四-回溯法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四-回溯法"}},[a._v("#")]),a._v(" (四)回溯法")]),a._v(" "),t("p",[a._v("适用特征：该问题是求解组合数量较大；需要找出该问题的解集（全部解）或者要求回答什么解是满足某些约束条件的最优解。")]),a._v(" "),t("p",[a._v("典型代表：哈密顿回路问题、八皇后问题、批处理作业调度......")]),a._v(" "),t("h2",{attrs:{id:"分治算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分治算法"}},[a._v("#")]),a._v(" 分治算法")]),a._v(" "),t("h3",{attrs:{id:"一、基本概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、基本概念"}},[a._v("#")]),a._v(" 一、基本概念")]),a._v(" "),t("p",[a._v("在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……")]),a._v(" "),t("p",[a._v("任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。")]),a._v(" "),t("h3",{attrs:{id:"二、基本思想及策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、基本思想及策略"}},[a._v("#")]),a._v(" 二、基本思想及策略")]),a._v(" "),t("p",[a._v("分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。")]),a._v(" "),t("p",[a._v("分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("如果原问题可分割成k个子问题，1<k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。\n")])])]),t("h3",{attrs:{id:"可使用分治法求解的一些经典问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可使用分治法求解的一些经典问题"}},[a._v("#")]),a._v(" 可使用分治法求解的一些经典问题")]),a._v(" "),t("p",[a._v("（1）二分搜索")]),a._v(" "),t("p",[a._v("（2）大整数乘法")]),a._v(" "),t("p",[a._v("（3）Strassen矩阵乘法")]),a._v(" "),t("p",[a._v("（4）棋盘覆盖")]),a._v(" "),t("p",[a._v("（5）合并排序")]),a._v(" "),t("p",[a._v("（6）快速排序")]),a._v(" "),t("p",[a._v("（7）线性时间选择")]),a._v(" "),t("p",[a._v("（8）最接近点对问题")]),a._v(" "),t("p",[a._v("（9）循环赛日程表")]),a._v(" "),t("p",[a._v("（10）汉诺塔")]),a._v(" "),t("h3",{attrs:{id:"依据分治法设计程序时的思维过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#依据分治法设计程序时的思维过程"}},[a._v("#")]),a._v(" 依据分治法设计程序时的思维过程")]),a._v(" "),t("p",[a._v("实际上就是类似于数学归纳法，找到解决本问题的基本求解方程公式，然后根据方程公式设计递归程序。")]),a._v(" "),t("p",[a._v("1、一定是先找到最小问题规模时的求解方法")]),a._v(" "),t("p",[a._v("2、然后考虑随着问题规模增大时的求解方法")]),a._v(" "),t("p",[a._v("3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。")]),a._v(" "),t("h2",{attrs:{id:"动态规划算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态规划算法"}},[a._v("#")]),a._v(" 动态规划算法")]),a._v(" "),t("h3",{attrs:{id:"一、基本概念-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、基本概念-2"}},[a._v("#")]),a._v(" 一、基本概念")]),a._v(" "),t("p",[a._v("动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。")]),a._v(" "),t("h3",{attrs:{id:"二、基本思想与策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、基本思想与策略"}},[a._v("#")]),a._v(" 二、基本思想与策略")]),a._v(" "),t("p",[a._v("基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。")]),a._v(" "),t("p",[a._v("由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。")]),a._v(" "),t("p",[a._v("与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。")]),a._v(" "),t("h3",{attrs:{id:"三、适用的情况"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、适用的情况"}},[a._v("#")]),a._v(" 三、适用的情况")]),a._v(" "),t("p",[a._v("能采用动态规划求解的问题的一般要具有3个性质：")]),a._v(" "),t("p",[a._v("(1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。")]),a._v(" "),t("p",[a._v("(2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。")]),a._v(" "),t("p",[a._v("（3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）")]),a._v(" "),t("h3",{attrs:{id:"四、求解的基本步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、求解的基本步骤"}},[a._v("#")]),a._v(" 四、求解的基本步骤")]),a._v(" "),t("p",[a._v("动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。")]),a._v(" "),t("p",[a._v("初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态")]),a._v(" "),t("p",[a._v("图1 动态规划决策过程示意图")]),a._v(" "),t("ul",[t("li",[a._v("(1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。")]),a._v(" "),t("li",[a._v("(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。")]),a._v(" "),t("li",[a._v("(3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。")]),a._v(" "),t("li",[a._v("(4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。")])]),a._v(" "),t("p",[a._v("一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。")]),a._v(" "),t("p",[a._v("实际应用中可以按以下几个简化的步骤进行设计：")]),a._v(" "),t("p",[a._v("（1）分析最优解的性质，并刻画其结构特征。")]),a._v(" "),t("p",[a._v("（2）递归的定义最优解。")]),a._v(" "),t("p",[a._v("（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值")]),a._v(" "),t("p",[a._v("（4）根据计算最优值时得到的信息，构造问题的最优解")]),a._v(" "),t("h3",{attrs:{id:"算法实现的说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法实现的说明"}},[a._v("#")]),a._v(" 算法实现的说明")]),a._v(" "),t("p",[a._v("动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。")]),a._v(" "),t("p",[a._v("使用动态规划求解问题，最重要的就是确定动态规划三要素：")]),a._v(" "),t("p",[a._v("（1）问题的阶段 （2）每个阶段的状态")]),a._v(" "),t("p",[a._v("（3）从前一个阶段转化到后一个阶段之间的递推关系。")]),a._v(" "),t("p",[a._v("递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。")]),a._v(" "),t("p",[a._v("确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。")]),a._v(" "),t("p",[a._v("f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}")]),a._v(" "),t("p",[a._v("总结：")]),a._v(" "),t("p",[a._v("1.找到dp[][][][],决定的数组定位具体情况，一个[]对应一个递归式子；")]),a._v(" "),t("p",[a._v("2.从初始值找特殊情况；")]),a._v(" "),t("p",[a._v("3.从初始值找递推式子（自上而下）或者从最后找关系（自下而上）；")]),a._v(" "),t("p",[a._v("接下来，我们就进行一下总结：")]),a._v(" "),t("p",[a._v("递归到动规的一般转化方法")]),a._v(" "),t("p",[a._v("递归函数有n个参数，就定义一个n维的数组，数组的下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值，这样就可以从边界值开始， 逐步填充数组，相当于计算递归函数值的逆过程。")]),a._v(" "),t("h3",{attrs:{id:"动规解题的一般思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动规解题的一般思路"}},[a._v("#")]),a._v(" 动规解题的一般思路")]),a._v(" "),t("ol",[t("li",[a._v("将原问题分解为子问题")])]),a._v(" "),t("p",[a._v("把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决(数字三角形例）。")]),a._v(" "),t("p",[a._v("子问题的解一旦求出就会被保存，所以每个子问题只需求 解一次。")]),a._v(" "),t("p",[a._v("2.确定状态")]),a._v(" "),t("p",[a._v("在用动态规划解题时，我们往往将和子问题相关的各个变量的一组取值，称之为一个“状 态”。一个“状态”对应于一个或多个子问题， 所谓某个“状态”下的“值”，就是这个“状 态”所对应的子问题的解。")]),a._v(" "),t("p",[a._v("所有“状态”的集合，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关。 在数字三角形的例子里，一共有N×(N+1)/2个数字，所以这个问题的状态空间里一共就有N×(N+1)/2个状态。")]),a._v(" "),t("p",[a._v("整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。在数字三角形里每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。")]),a._v(" "),t("p",[a._v("3.确定一些初始状态（边界状态）的值")]),a._v(" "),t("p",[a._v("以“数字三角形”为例，初始状态就是底边数字，值就是底边数字值。")]),a._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[a._v("确定状态转移方程")])]),a._v(" "),t("p",[a._v("定义出什么是“状态”，以及在该“状态”下的“值”后，就要找出不同的状态之间如何迁移――即如何从一个或多个“值”已知的 “状态”，求出另一个“状态”的“值”(递推型)。状态的迁移可以用递推公式表示，此递推公式也可被称作“状态转移方程”。")]),a._v(" "),t("h3",{attrs:{id:"数字三角形的状态转移方程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数字三角形的状态转移方程"}},[a._v("#")]),a._v(" 数字三角形的状态转移方程:")]),a._v(" "),t("p",[a._v("能用动规解决的问题的特点")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("问题具有最优子结构性质。如果问题的最优解所包含的 子问题的解也是最优的，我们就称该问题具有最优子结 构性质。")])]),a._v(" "),t("li",[t("p",[a._v("无后效性。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。")])])]),a._v(" "),t("h2",{attrs:{id:"参考文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[a._v("#")]),a._v(" 参考文章")]),a._v(" "),t("ul",[t("li",[a._v("https://baijiahao.baidu.com/s?id=1660742044135451900")])])])}),[],!1,null,null,null);v.default=r.exports}}]);