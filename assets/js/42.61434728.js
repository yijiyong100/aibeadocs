(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{558:function(t,a,s){"use strict";s.r(a);var _=s(53),v=Object(_.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("本文主要是介绍 推荐系统-推荐算法详解 。")])]),t._v(" "),s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#个性化推荐算法-推荐系统-概要"}},[t._v("个性化推荐算法（推荐系统）概要")])]),s("li",[s("a",{attrs:{href:"#一、推荐算法与产品介绍"}},[t._v("一、推荐算法与产品介绍")]),s("ul",[s("li",[s("a",{attrs:{href:"#什么是推荐系统"}},[t._v("什么是推荐系统？")])]),s("li",[s("a",{attrs:{href:"#个性化召回"}},[t._v("个性化召回")])]),s("li",[s("a",{attrs:{href:"#_1、什么是个性化召回"}},[t._v("1、什么是个性化召回？")])]),s("li",[s("a",{attrs:{href:"#_2、召回的重要作用"}},[t._v("2、召回的重要作用")])]),s("li",[s("a",{attrs:{href:"#_3、工业界个性化召回架构"}},[t._v("3、工业界个性化召回架构")])]),s("li",[s("a",{attrs:{href:"#第一大类是离线模型"}},[t._v("- 第一大类是离线模型")])]),s("li",[s("a",{attrs:{href:"#第二大类是深度学习模型"}},[t._v("- 第二大类是深度学习模型")])]),s("li",[s("a",{attrs:{href:"#_1-基于用户维度的推荐"}},[t._v("1. 基于用户维度的推荐")])])])]),s("li",[s("a",{attrs:{href:"#二、召回算法概述"}},[t._v("二、召回算法概述")]),s("ul",[s("li",[s("a",{attrs:{href:"#一、推荐召回算法概述"}},[t._v("一、推荐召回算法概述")])]),s("li",[s("a",{attrs:{href:"#_1-非个性化范式"}},[t._v("1. 非个性化范式")])]),s("li",[s("a",{attrs:{href:"#_2-完全个性化范式"}},[t._v("2. 完全个性化范式")])]),s("li",[s("a",{attrs:{href:"#_1-基于内容的个性化推荐算法"}},[t._v("（1）基于内容的个性化推荐算法")])]),s("li",[s("a",{attrs:{href:"#_2-基于协同过滤的推荐算法"}},[t._v("（2）基于协同过滤的推荐算法")])]),s("li",[s("a",{attrs:{href:"#_3-基于模型的推荐算法"}},[t._v("（3）基于模型的推荐算法")])]),s("li",[s("a",{attrs:{href:"#_3-群组个性化范式"}},[t._v("3. 群组个性化范式")])]),s("li",[s("a",{attrs:{href:"#_4-标的物关联标的物范式"}},[t._v("4. 标的物关联标的物范式")])]),s("li",[s("a",{attrs:{href:"#_3-基于标签推荐"}},[t._v("（3） 基于标签推荐")])]),s("li",[s("a",{attrs:{href:"#_4-基于标的物聚类的推荐"}},[t._v("（4）基于标的物聚类的推荐")])]),s("li",[s("a",{attrs:{href:"#_5-笛卡尔积范式"}},[t._v("5. 笛卡尔积范式")])]),s("li",[s("a",{attrs:{href:"#个性化召回算法"}},[t._v("个性化召回算法")])]),s("li",[s("a",{attrs:{href:"#item-cf在工业界落地公式升级1"}},[t._v("Item CF在工业界落地公式升级1：")])]),s("li",[s("a",{attrs:{href:"#item-cf在工业界落地公式升级2"}},[t._v("Item CF在工业界落地公式升级2：")])]),s("li",[s("a",{attrs:{href:"#user-collaborative-filtering-user-cf"}},[t._v("User Collaborative Filtering(User CF)")])]),s("li",[s("a",{attrs:{href:"#工业界落地时公式升级1"}},[t._v("工业界落地时公式升级1:")])]),s("li",[s("a",{attrs:{href:"#公式升级2-工业界"}},[t._v("公式升级2（工业界）")])]),s("li",[s("a",{attrs:{href:"#itemcf-vs-usercf-优缺点比较"}},[t._v("Itemcf VS Usercf优缺点比较：")])]),s("li",[s("a",{attrs:{href:"#推荐理由的可解释性"}},[t._v("推荐理由的可解释性")])]),s("li",[s("a",{attrs:{href:"#item-cf-vs-user-cf适用场景"}},[t._v("Item cf VS User cf适用场景")])])])]),s("li",[s("a",{attrs:{href:"#三、排序算法概述"}},[t._v("三、排序算法概述")]),s("ul",[s("li",[s("a",{attrs:{href:"#_1-logistic回归模型"}},[t._v("1. logistic回归模型")])]),s("li",[s("a",{attrs:{href:"#_2-gbdt模型"}},[t._v("2. GBDT模型")])]),s("li",[s("a",{attrs:{href:"#_3-wide-deep模型"}},[t._v("3. Wide & deep模型")])])])]),s("li",[s("a",{attrs:{href:"#四、推荐算法落地需要关注的几个问题"}},[t._v("四、推荐算法落地需要关注的几个问题")]),s("ul",[s("li",[s("a",{attrs:{href:"#_1-推荐算法工程落地是否一定需要排序模块"}},[t._v("1. 推荐算法工程落地是否一定需要排序模块")])]),s("li",[s("a",{attrs:{href:"#_2-推荐算法服务于用户的两种形式"}},[t._v("2. 推荐算法服务于用户的两种形式")])]),s("li",[s("a",{attrs:{href:"#_3-推荐系统评估"}},[t._v("3. 推荐系统评估")])])])]),s("li",[s("a",{attrs:{href:"#参考文章"}},[t._v("参考文章")])])])]),s("p"),t._v(" "),s("h2",{attrs:{id:"个性化推荐算法-推荐系统-概要"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#个性化推荐算法-推荐系统-概要"}},[t._v("#")]),t._v(" 个性化推荐算法（推荐系统）概要")]),t._v(" "),s("h2",{attrs:{id:"一、推荐算法与产品介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、推荐算法与产品介绍"}},[t._v("#")]),t._v(" 一、推荐算法与产品介绍")]),t._v(" "),s("h3",{attrs:{id:"什么是推荐系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是推荐系统"}},[t._v("#")]),t._v(" "),s("strong",[t._v("什么是推荐系统？")])]),t._v(" "),s("p",[t._v("在介绍推荐算法之前需要先介绍一下什么是信息过载。")]),t._v(" "),s("p",[t._v("信息过载就是信息的数量远超于人手工可以遍历的数量。比如，当你没有目的性的去逛超市，你不可能把所有的商品都看一遍都有什么。同样，无论是去书店看书，还是在电影网站上搜索电影，这些物品的量级对于没有目的性、需求性的用户而言都是信息过载。")]),t._v(" "),s("p",[t._v("那么什么是推荐系统呢？")]),t._v(" "),s("p",[t._v("就是当用户的目的不明确、且该服务对于用户而言构成了信息过载；但该系统基于一定的策略规则，将物品进行了排序，并将前面的物品展示给了用户，这样的系统就可以称之为推荐系统。")]),t._v(" "),s("p",[t._v("举例说明，在网站购物过程中，无论是天猫或者京东这样的平台，如果我们有明确的需求去搜索框里检索。如希望买啤酒，那么检索结果就是很多种类的啤酒；如果没有明确的需求，就会有猜你喜欢等等模块，这些模块就是推荐系统基于一定的规则策略计算出来的，这些规则策略就是个性化推荐算法。")]),t._v(" "),s("p",[t._v("在工业级推荐系统的推荐业务流程一般分为召回和排序两个阶段，召回就是将用户可能会感兴趣的标的物通过算法从全量标的物库中取出来，一般会采用多个算法来召回，比如热门召回、协同过滤召回、标签召回等，排序阶段将召回阶段的标的物列表根据用户可能的点击概率大小排序(即所谓的ctr预估)。在实际业务中，在排序后还会增加一层调控逻辑，根据业务规则及运营策略对排序后的列表进一步增补微调，满足特定的运营需求。")]),t._v(" "),s("h3",{attrs:{id:"个性化召回"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#个性化召回"}},[t._v("#")]),t._v(" "),s("strong",[t._v("个性化召回")])]),t._v(" "),s("h3",{attrs:{id:"_1、什么是个性化召回"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、什么是个性化召回"}},[t._v("#")]),t._v(" "),s("strong",[t._v("1、什么是个性化召回？")])]),t._v(" "),s("p",[t._v("在item全集中选取一部分作为候选集。这里就存在一个问题，就是说为什么要选取一部分作为作为候选集，而不是全部？其原因在于：")]),t._v(" "),s("ul",[s("li",[t._v("1.不同的用户不会喜欢所有类型的item；")]),t._v(" "),s("li",[t._v("2.基于服务性能的考虑，如果选择了全部的item作为候选集，对于后续的排序就将耗费大量的时间，对于整体推荐的后端，服务响应时间将会是灾难性的。")])]),t._v(" "),s("p",[t._v("根据用户的属性行为上下文等信息从物品全集中选取其感兴趣的物品作为候选集。")]),t._v(" "),s("p",[t._v("下面举例说明：")]),t._v(" "),s("p",[t._v("如果某个推荐系统中，物品全集是如下左图中9个item，这里有两个用户A和B，他们分别对不同的item感兴趣。这里拿信息流产品举例，如果user A对体育类新闻感兴趣，user B对娱乐类新闻感兴趣，那就按照简单的类别召回，得到结果如下右图所示。")]),t._v(" "),s("p",[t._v("在候选集{a,b,c,….,g,h,i}中为User A,User B选取一部分item作为候选集")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/20200516193428875.png"),alt:"wxmp"}}),t._v(" "),s("h3",{attrs:{id:"_2、召回的重要作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、召回的重要作用"}},[t._v("#")]),t._v(" "),s("strong",[t._v("2、召回的重要作用")])]),t._v(" "),s("p",[t._v("召回决定了最终推荐结果的天花板")]),t._v(" "),s("p",[t._v("为什么这么说呢？这里先看一下推荐系统的整体架构，工业中的个性化推荐系统中的策略部分的架构主要由一下三部分构成：召回、排序、以及最后的策略调整部分（同上文提到），其中召回部分包括各路个性化召回之后将所有的item merge进入rank部分，rank只是调整召回完item的展现顺序，rank完之后还有一些策略的调整，比如信息流场景中的控制相同作者的数目等等，所以可以看到个性化召回的候选集是多么的重要，因为最终展现给用户的就是从这个候选集中选出来的。那么就可能会有疑问，为什么不能将所有的item进行排序？这是为了保证后端响应时间。")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/20200516193649529.png"),alt:"wxmp"}}),t._v(" "),s("p",[t._v("与用户离的最近的是端，在移动互联网的时代主要的流量集中在了移动app也可以是网站前端。连接接前后端的是WEB API层。WEB层主要给APP端提供API服务，解析端上发来的请求，调用后端rpc服务。得到的结果投全到端上。web api层尽量不做策略业务逻辑，但是会做一些诸如log写实时信息队列，或写分布式存储这样的事情来方便后续的数据分析和模型训练。")]),t._v(" "),s("p",[t._v("最后是后端的RPC服务。个性化推荐算法主要发挥作用的部分。")]),t._v(" "),s("p",[s("strong",[t._v("RPC服务的三大策略部分")]),t._v("。")]),t._v(" "),s("ul",[s("li",[t._v("第一：个性化召回，基于用户的行为，通过算法模型来为用户精准推荐。或基于用户画像的标签推荐同类型的item。举个栗子，如果某个用户过往经常点击体育类的item，那么用户画像就给她标上体育的lable。那么有较新的体育类新闻，会优先推荐给改用户。召回决定了最终推荐结果的天花板，因为这一步决定了候选集。")]),t._v(" "),s("li",[t._v("第二部分：排序部分。第一部分召回了用户感兴趣的物品集合后，我们需要决策\n出展现给用户的顺序。好的顺序可以让用户在列表的开始找到自己的所需，完成转化。因为用户的每一次下拉都是有成本的，如何不能在最初的几屏里，显示用户的所需，用户就很可能流失掉。结合刚才召回所举的例子，给用户召回了体育类的item，不同的item可能会有不同的浏览人数，评论人数，发布时间，不同的字数，不同的时长，不同的发布时间等等，同样该用户也有体育类的细分的倾向性。")]),t._v(" "),s("li",[t._v("第三部分：策略调整部分，基于业务场景的策略调整部分。由于召回和排序大多数是基于模型来做的，所以基于业务场景的策略调整部分可以增加一些规则来fit业务场景。比如在信息流场景中，我们不希望给用户一直连续推荐同一个作者的新闻，我们可以加一些打散的策略。")])]),t._v(" "),s("h3",{attrs:{id:"_3、工业界个性化召回架构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、工业界个性化召回架构"}},[t._v("#")]),t._v(" "),s("strong",[t._v("3、工业界个性化召回架构")])]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/20200516193904258.png"),alt:"wxmp"}}),t._v(" "),s("p",[t._v("整体的召回架构可以分为两大类：")]),t._v(" "),s("h3",{attrs:{id:"第一大类是离线模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第一大类是离线模型"}},[t._v("#")]),t._v(" - 第一大类是离线模型")]),t._v(" "),s("p",[t._v("根据用户行为基于离线的model file算出推荐结果，这些推荐结果可以是用户喜欢哪些item集合，也可以是item之间的相似度文件 ，计算出具有某种lable的item的排序。然后离线计算好的排序的文件写入KV存储。在用户访问服务的时候，Recall部分直接从KV中读取。因为我们直接存储的是item ID,我们读取到的item id的时候还需要去Detail Server中得到每个item id的详情，然后将详情拼接好传给rank。(在线的server recall部分直接调用这个结果，拿到ID之后访问detail server得到详情，再往rank部分传递)")]),t._v(" "),s("h3",{attrs:{id:"第二大类是深度学习模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第二大类是深度学习模型"}},[t._v("#")]),t._v(" - 第二大类是深度学习模型")]),t._v(" "),s("p",[t._v("如果采用深度学习的一些model，这是需要将model file算出来的item embedding的向量也需要离线存入KV中，但是用户在访问我们的KV的时候，在线访问深度学习模型服务（recall server）的User embedding。同时去将user embedding层的向量和item embedding层的向量做最近邻计算，并得到召回。")]),t._v(" "),s("p",[t._v("下面是电视猫(一款基于OTT端[智能电视或者智能盒子]的视频播放软件)的推荐系统的业务流程，包含召回、排序和业务调控三大算法和策略模块，可以作为大家设计推荐系统算法模块的参考。")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/20200516175909109.png"),alt:"wxmp"}}),t._v(" "),s("p",[t._v("推荐算法是一种机器学习算法，所以算法模型的质量强依赖于用于算法训练的数据集，这里我们简单提下推荐系统可以利用的数据有哪些(参考下面图及上面图的数据源)。一般推荐系统依赖三大类数据：标的物metadata数据(标的物相关的描述信息)、用户画像数据(用户相关数据，如年龄、地域、性别、收入等)、用户行为数据(用户对标的物的操作行为，如播放、点击、购买、收藏等)。这三类数据是主要可用的模型数据。另外人工标注数据、第三方数据等也可以用来补充完善上述三类数据。")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/20200516180241254.png"),alt:"wxmp"}}),t._v(" "),s("p",[t._v("相信大家对推荐流程及算法依赖的数据有了初步了解，下面我们来根据不同的推荐范式重点讲解对应的推荐产品及可行的推荐算法，方便大家将不同的推荐算法对应到不同的推荐产品中。")]),t._v(" "),s("p",[t._v("上面我们提到的5类推荐范式，可以从三个维度来理解：")]),t._v(" "),s("ul",[s("li",[t._v("一个是用户维度\n-一 个是标的物维度")]),t._v(" "),s("li",[t._v("一个是用户与标的物笛卡尔积维度")])]),t._v(" "),s("p",[t._v("从用户维度来看就是为用户推荐可能感兴趣的标的物，从标的物维度来看，就是用户在访问标的物详情页(或者退出标的物详情页)时，关联一组标的物作为推荐。第三个维度是将用户维度和标的物维度结合起来，不同的用户访问同样的标的物详情页看到的内容也不一样。")]),t._v(" "),s("h3",{attrs:{id:"_1-基于用户维度的推荐"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-基于用户维度的推荐"}},[t._v("#")]),t._v(" "),s("strong",[t._v("1. 基于用户维度的推荐")])]),t._v(" "),s("p",[t._v("基于用户维度的推荐可以根据个性化的力度分为非个性化、群组个性化、完全个性化。这三种粒度对应我们前面提到的非个性化范式、群组个性化范式、完全个性化范式。")]),t._v(" "),s("p",[t._v("非个性化是每个用户看到的推荐内容都完全一样，传统门户网站的编辑对内容的编排就是非个性化的方式，每个用户看到的内容都是一样的。对于各类网站或者APP的排行榜的推荐形态也是非个性化的。下面图是网易云音乐的排行榜推荐，根据各个维度计算各类榜单。")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/20200516180835519.png"),alt:"wxmp"}}),t._v(" "),s("p",[t._v("群组个性化就是将相同特征的用户聚合成一组，同一组用户在某些特征上具备相似性，我们为这一组用户推荐完全一样的内容。")]),t._v(" "),s("p",[t._v("精细化运营一般会采用该方式，通过用户画像系统圈一批人，并对这批人做统一的运营。比如视频行业的会员精细化运营，当会员快到期时，可以借助精准运营留住用户，具体可以将快到期的会员用户圈出来，针对这批用户做会员打折活动，促进用户产生新的购买。")]),t._v(" "),s("p",[t._v("下图是电视猫电视剧频道”战争风云“tab的基于群组的个性化重排序。我们将用户根据兴趣分组(聚类)，同一组内的用户看到的内容是一样的顺序，但是不同组的用户的排序是不一样的。但是不管哪个用户其实看到的内容集合(战争风云tab的全部内容)是相同的，只不过根据用户的兴趣做了排序，把用户更喜欢的内容排在了前面。")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/20200516181253253.png"),alt:"wxmp"}}),t._v(" "),s("p",[t._v("对于天猫这类购物网站来说，对未登录用户或是冷启动的用户，可以采用基于人群属性来做推荐。通过将用户按照性别、年龄段、收货城市等粗粒度的属性划分为若干人群，然后基于每个人群的行为数据挑选出该人群点击率最高的TopK个商品作为该人群感兴趣的商品推荐给他们。该方法也是一种群组个性化推荐策略。")]),t._v(" "),s("p",[t._v("完全个性化就是为每个用户推荐的内容都不一样，是根据用户的行为及兴趣来为用户做推荐，是最常用的一种推荐形式。大多数时候我们所说的推荐就是指这种形式的推荐。下图是淘宝首页的猜你喜欢推荐，这个推荐就是完全个性化的，每个人推荐的都不一样。")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/20200516181430546.png"),alt:"wxmp"}}),t._v(" "),s("p",[t._v("完全个性化也可以基于用户的好友关系来做推荐。下面图是微信最近上线的好物推荐，是基于社交关系的个性化推荐，将你的好友买过的商品推荐给你。")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/2020051618150624.png"),alt:"wxmp"}}),t._v(" "),s("p",[t._v("从另外一个角度看，完全个性化推荐可以分为只基于用户个人行为的推荐和基于群组行为的推荐。基于个人行为的推荐，在构建推荐算法时只依赖个人的行为，不需要其他用户的行为，常见的基于内容推荐就是这类推荐。基于群组行为的推荐，除了利用自己的行为外，还依赖其他用户的行为构建算法模型，这类推荐可以认为是全体用户的“协同进化“，像协同过滤、基于模型的推荐等都是这类推荐形式。")]),t._v(" "),s("p",[s("strong",[t._v("2. 基于标的物维度的推荐")])]),t._v(" "),s("p",[t._v("基于标的物维度的推荐是用户在访问标的物详情页时，或者访问后退出时，关联一批相似或者相关的标的物列表，对应我们上面提到的标的物关联标的物范式。下图是电视猫APP节目详情页的相似影片，就是常见的一类标的物关联标的物的推荐模式。\n"),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/20200516181747497.png"),alt:"wxmp"}}),t._v("除了视频网站外，电商、短视频等APP都大量使用基于标的物维度的推荐。下图分别是淘宝APP和网易新闻APP上的标的物关联标的物推荐。淘宝APP上当你点击某个衣服详情页后从该详情页退出，就会在该衣服图片下面用小图展示4个相关的衣服(下面左图红色圈圈部分)，网易新闻视频模块当你点击播放一个视频超过几秒后就会在该视频下面展示一行相关视频(见下面右图红色圈圈部分)，如果你一直播放，当该视频播完后会播放后面的相似视频，最终形成连播推荐的效果。这两款APP的相似推荐都是非常好的推荐形态，交互非常自然流畅，毫无违和感。")]),t._v(" "),s("p",[s("strong",[t._v("3. 基于用户和标的物交叉维度的推荐")])]),t._v(" "),s("p",[t._v("这类推荐，不同用户对同一个标的物的关联推荐是不一样的，对应我们上面提到的笛卡尔积范式。还是拿电视猫来举例，如果该推荐是用户与标的物笛卡尔积式的推荐的话，不同用户看到双重约会这个电影，下面的相似影片是不一样的，推荐会整合用户的兴趣特征，过滤掉用户已经看过的电影等等。对于搜索来说，不同的人搜索同一个关键词得到的搜索结果及排序是不同的，搜索结果及排序整合了个人的历史行为特征及兴趣。")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/20200516182302405.png"),alt:"wxmp"}}),t._v(" "),s("p",[t._v("这类推荐由于每个用户在每个标的物上的推荐列表都不一样，我们没法事先将所有的组合算出并存下来(否则存储量是用户数 × 标的物数，对于互联网公司，这个数量是巨大的)，我们必须在用户请求的过程中快速地为用户计算个性化的推荐列表，这对整个推荐系统的架构有更高的要求，所以在实际场景中用得比较少。")]),t._v(" "),s("h2",{attrs:{id:"二、召回算法概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、召回算法概述"}},[t._v("#")]),t._v(" 二、召回算法概述")]),t._v(" "),s("h3",{attrs:{id:"一、推荐召回算法概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、推荐召回算法概述"}},[t._v("#")]),t._v(" 一、推荐召回算法概述")]),t._v(" "),s("h3",{attrs:{id:"_1-非个性化范式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-非个性化范式"}},[t._v("#")]),t._v(" "),s("strong",[t._v("1. 非个性化范式")])]),t._v(" "),s("p",[t._v("非个性化范式就是所有用户推荐一样的标的物列表，一般各种榜单就是这类推荐，如最新榜、最热榜等等。这类排行榜就是基于某个规则来对标的物降序排列，将排序后的标的物取topN推荐给用户。比如最新榜可以根据标的物上线的时间顺序来倒序排列，取前面的topN推荐给用户。最热榜可以根据用户播放量(点击量)降序排列。")]),t._v(" "),s("p",[t._v("这里面可能需要考虑标的物的多品类特性，甚至还会考虑地域、时间、价格等各个维度。在具体实施时会比较复杂，需要根据具体的产品及业务场景来设计。")]),t._v(" "),s("p",[t._v("非个性化范式可以基于简单的计数统计来生成推荐，基本不会用到很复杂的机器学习算法。当然，用来取topN的排行榜计算公式可能会整合各类用户行为数据，公式会比较复杂(如豆瓣评分公式就比较复杂)。")]),t._v(" "),s("p",[t._v("非个性化范式的排行榜等算法，实现起来很简单，可解释性也很强。虽然每个用户推荐的内容都一样，但是(从生物进化上)人都是有从众心理的，大家都喜欢的东西，我们也喜欢的概率还是很大的，所以这类推荐效果还是非常不错的。这类算法也可以作为冷启动或者默认的推荐算法。")]),t._v(" "),s("h3",{attrs:{id:"_2-完全个性化范式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-完全个性化范式"}},[t._v("#")]),t._v(" "),s("strong",[t._v("2. 完全个性化范式")])]),t._v(" "),s("p",[t._v("完全个性化范式是最常用的推荐模式，可用的推荐方法非常多。下面对常用的算法及最新的算法进展进行简单梳理。")]),t._v(" "),s("h3",{attrs:{id:"_1-基于内容的个性化推荐算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-基于内容的个性化推荐算法"}},[t._v("#")]),t._v(" "),s("strong",[t._v("（1）基于内容的个性化推荐算法")])]),t._v(" "),s("p",[t._v("这类推荐算法只依赖于用户自己的历史行为而不必知道其他用户的行为。该算法的核心思想是：标的物是有描述属性的，用户对标的物的操作行为为用户打上了相关属性的烙印，这些属性就是用户的兴趣标签，那么我们就可以基于用户的兴趣来为用户生成推荐列表。拿视频推荐来举例，如果用户过去看了科幻和恐怖两类电影，那么恐怖、科幻就是用户的偏好标签了，这时我们就可以给用户推荐科幻、恐怖类的其他电影。具体来说，我们有如下两类方法来为用户做推荐。")]),t._v(" "),s("h4",{attrs:{id:"a-基于用户特征表示的推荐"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#a-基于用户特征表示的推荐"}},[t._v("#")]),t._v(" a 基于用户特征表示的推荐")]),t._v(" "),s("p",[t._v("标的物是具备很多文本特征的，比如标签、描述信息、metadata信息等。我们可以将这些文本信息采用TF-IDF或者LDA等算法转化为特征向量，如果是用标签来描述标的物，那么我们可以构建一个以标签为特征的特征向量。")]),t._v(" "),s("p",[t._v("有了特征向量，就可以将用户所有操作过的标的物的特征向量的(时间加权)平均作为用户的特征向量，利用用户特征向量与标的物特征向量的乘积就可以计算用户与标的物的相似度，从而计算出用户的推荐列表。")]),t._v(" "),s("h4",{attrs:{id:"b-基于倒排索引查询的推荐"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#b-基于倒排索引查询的推荐"}},[t._v("#")]),t._v(" b 基于倒排索引查询的推荐")]),t._v(" "),s("p",[t._v("如果我们基于标签来表示标的物属性，那么基于用户的历史行为，可以构建用户的兴趣画像，该画像即是用户对各个标签的偏好，并且有相应的偏好权重。")]),t._v(" "),s("p",[t._v("构建完用户画像后，我们可以构建出标签与标的物的倒排索引查询表(熟悉搜索的同学应该不难理解)。基于该反向索引表及用户的兴趣画像，我们就可以为用户做个性化推荐了。该类算法其实就是基于标签的召回算法。")]),t._v(" "),s("p",[t._v("具体推荐过程是这样的(见下面图)：从用户画像中获取用户的兴趣标签，基于用户的兴趣标签从倒排索引表中获取该标签对应的节目，这样就可以从用户关联到节目了。其中用户的每个兴趣标签及标签关联到的标的物都是有权重的。")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/2020051618411983.png"),alt:"wxmp"}}),t._v(" "),s("p",[t._v("该类推荐算法是非常自然直观的，可解释性强。同时可以较好地解决冷启动，只要用户有一次行为，就可以基于该行为做推荐。但是，该类算法往往新颖性不足，给用户的推荐往往局限在一个狭小的范围中，如果用户不主动拓展自己的兴趣空间，该方法很难为用户推荐新颖的内容。")]),t._v(" "),s("h3",{attrs:{id:"_2-基于协同过滤的推荐算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-基于协同过滤的推荐算法"}},[t._v("#")]),t._v(" "),s("strong",[t._v("（2）基于协同过滤的推荐算法")])]),t._v(" "),s("p",[t._v("基于协同过滤的推荐算法，核心思想是很朴素的”物以类聚、人以群分“的思想。所谓物以类聚，就是计算出每个标的物最相似的标的物列表，我们就可以为用户推荐用户喜欢的标的物相似的标的物，这就是基于物品的协同过滤。所谓人以群分，就是我们可以将与该用户相似的用户喜欢过的标的物(而该用户未曾操作过)的标的物推荐给该用户，这就是基于用户的协同过滤。具体思想可以参考下图。")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/20200516185239787.png"),alt:"wxmp"}}),t._v(" "),s("p",[t._v("协同过滤的核心是怎么计算标的物之间的相似度以及用户之间的相似度。我们可以采用非常朴素的思想来计算相似度。")]),t._v(" "),s("p",[t._v("我们将用户对标的物的评分(或者隐式反馈，如点击等)构建如下矩阵(见下)\n(  R11  R12 …  R1m  R21  R22 …  R2m  Rn1  Rn2 …  Rnm ) \\left(")]),t._v(" "),s("p",[t._v("\\right) ⎝⎜⎜⎛ R11 R21 Rn1  R12 R22 Rn2 ……… R1m R2m Rnm ⎠⎟⎟⎞")]),t._v(" "),s("p",[t._v("矩阵的某个元素代表某个用户对某个标的物的评分(如果是隐式反馈，值为1)，如果某个用户对某个标的物未产生行为，值为0。其中行向量代表某个用户对所有标的物的评分向量，列向量代表所有用户对某个标的物的评分向量。有了行向量和列向量，我们就可以计算用户与用户之间、标的物与标的物之间的相似度了。具体来说，行向量之间的相似度就是用户之间的相似度，列向量之间的相似度就是标的物之间的相似度。相似度的计算可以采用cos余弦相似度算法。")]),t._v(" "),s("p",[t._v("在互联网产品中一般会采用基于物品的协同过滤，因为对于互联网产品来说，用户相对于标的物变化更大，用户是增长较快的，标的物增长相对较慢，利用基于物品的协同过滤算法效果更稳定。")]),t._v(" "),s("p",[t._v("协同过滤算法思路非常直观易懂，计算也相对简单，易于分布式实现，也不依赖于用户及标的物的其他信息，效果也非常好，也能够为用户推荐新颖性内容，所以在工业界得到非常广泛的应用。")]),t._v(" "),s("h3",{attrs:{id:"_3-基于模型的推荐算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-基于模型的推荐算法"}},[t._v("#")]),t._v(" "),s("strong",[t._v("（3）基于模型的推荐算法")])]),t._v(" "),s("p",[t._v("基于模型的推荐算法种类非常多，最常用的有矩阵分解算法、分解机算法等。目前深度学习算法、强化学习算法、迁移学习算法也在推荐系统中得到大规模采用。")]),t._v(" "),s("p",[t._v("基于模型的推荐算法，基于用户历史行为数据、标的物metadata、用户画像数据等构建一个机器学习模型，利用数据训练模型，求解模型参数。最终利用该模型来预测用户对未知标的物的偏好。下面图就是基于模型的推荐系统模型训练与预测的流程。\n"),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/20200516190014149.png"),alt:"wxmp"}}),t._v("基于模型的推荐算法有三类预测方式，一类是预测标的物的评分，基于评分的大小表示对标的物的偏好程度。第二类是采用概率的思路，预测用户对标的物的喜好概率，利用概率值的大小来预测用户对标的物的喜好程度。另外一类是采用分类的思路，将每个标的物看成一类，通过预测用户下一个(几个)标的物所属的类别来做推荐。矩阵分解算法就是预测用户对标的物的评分，logistic回归算法就是概率预测方法，而youtube发表的深度学习推荐就是基于分类思路的算法(参见参考文献10)。")]),t._v(" "),s("p",[t._v("矩阵分解算法是将用户评分矩阵M分解为两个矩阵U、V的乘积。U代表的用户特征矩阵，V代表标的物特征矩阵。某个用户对某个标的物的评分，就可以采用矩阵U对应的行(该用户的特征向量)与矩阵V对应的列(该标的物的特征向量)的乘积。分解机算法是矩阵分解算法的推广，这里不做介绍。")]),t._v(" "),s("p",[t._v("随着最近几年深度学习在图像识别、语音识别领域的大获成功。有很多研究者及工业实践者将深度学习用于推荐系统，也取得了非常好的成绩，如youtube、Netflix、阿里、京东、网易、携程等，都将深度学习部署到了实际推荐业务中，并取得了非常好的转化效果(参考后面的参考文献中对应的论文)。")]),t._v(" "),s("p",[t._v("强化学习及迁移学习等新的方法也开始在推荐业务中崭露头角，有兴趣的读者可以阅读文末对应的参考文献。")]),t._v(" "),s("h3",{attrs:{id:"_3-群组个性化范式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-群组个性化范式"}},[t._v("#")]),t._v(" "),s("strong",[t._v("3. 群组个性化范式")])]),t._v(" "),s("p",[t._v("群组个性化范式需要先将用户分组，分组的原则是非常重要的。一般有如下两类分组方案。")]),t._v(" "),s("h4",{attrs:{id:"_1-基于用户画像圈人的推荐"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-基于用户画像圈人的推荐"}},[t._v("#")]),t._v(" "),s("strong",[t._v("（1）基于用户画像圈人的推荐")])]),t._v(" "),s("p",[t._v("先基于用户的人口统计学数据或者用户行为数据构建用户画像。用户画像一般用于做精准的运营，通过显示特征将一批人圈起来，对这批人做针对性的运营。在前面也做了介绍，这里不再说明。")]),t._v(" "),s("h4",{attrs:{id:"_2-采用聚类算法的推荐"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-采用聚类算法的推荐"}},[t._v("#")]),t._v(" "),s("strong",[t._v("（2）采用聚类算法的推荐")])]),t._v(" "),s("p",[t._v("聚类是非常直观的一种思路，将行为偏好相似的用户聚成一类，他们有相似的兴趣。常用的聚类策略有如下两类。")]),t._v(" "),s("h4",{attrs:{id:"a-将用户嵌入一个高维向量空间-基于用户的向量表示做聚类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#a-将用户嵌入一个高维向量空间-基于用户的向量表示做聚类"}},[t._v("#")]),t._v(" - a 将用户嵌入一个高维向量空间，基于用户的向量表示做聚类")]),t._v(" "),s("p",[t._v("将用户相关特征嵌入向量空间的方式有很多，下面都是非常主流的做法。")]),t._v(" "),s("p",[t._v("采用基于内容推荐的思路，可以构建用户的特征向量(TF-IDF，LDA，标签等，前面已经介绍过)。有了用户的特征向量就可以聚类，该类所有用户特征向量的加权平均就是该组用户的特征向量，再利用群组特征向量与标的物特征向量的内积来计算群组与标的物的相似度，从而为该群组做个性化推荐。")]),t._v(" "),s("p",[t._v("采用基于用户的协同过滤的思路，可以构建用户和标的物的行为矩阵，矩阵的元素就是用户对标的物的评分，利用该矩阵的行向量就构建了一个衡量用户特征的向量，基于该特征向量可以对用户聚类。先对该组用户所有的特征向量求均值，可以取k个最大的特征，其他特征忽略不计(设置为0)，最终得到该组用户的特征。最后就可以根据基于用户协同过滤的思路来为该组用户计算推荐列表了。")]),t._v(" "),s("p",[t._v("利用矩阵分解可以得到每个用户的特征向量，我们可以用该组用户特征向量的均值来作为该用户组的特征向量。再利用用户组的特征向量与标的物特征向量的内积来计算群组对该标的物的偏好，所有偏好计算出来后，通过降序排列就可以为该组用户推荐topN的标的物列表了。前面我们提到的电视猫的重排序算法就是基于该思路实现的。")]),t._v(" "),s("p",[t._v("还可以基于词嵌入的方式，将每个用户对标的物的所有操作(购买、观看等)看成一个文档集合，标的物的sid就是一个单词，采用类似word2vec的方式可以获得标的物的向量表示(见参考文献9)，那么用户的向量表示就是用户操作过的所有标的物的向量表示的均值(可以采用时间加权，对最早操作的标的物给予最低的权重)，这样就获得了每个用户的特征向量了。该组所有用户的平均特征向量就是该组的特征向量。这时可以采用类似上面矩阵分解的方式计算该组特征向量与标的物特征向量的内积为该组用户做个性化推荐。")]),t._v(" "),s("p",[t._v("除了上面几种计算群组推荐的方法外，还有一种基于计数统计的更直观的推荐方法。当我们对用户进行聚类后，我们可以对这一组用户操作过的标的物采用计数的方式统计每个标的物被操作的次数，将同一标的物的操作次数累加，最后按照标的物计数大小按照降序排列。 将标的物列表topn推荐给该组，这个topN列表就是绝大多数人喜欢的标的物。")]),t._v(" "),s("h4",{attrs:{id:"b-基于图的聚类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#b-基于图的聚类"}},[t._v("#")]),t._v(" - b 基于图的聚类")]),t._v(" "),s("p",[t._v("我们可以构建用户关系图，顶点是用户，边是用户之间的关系，我们可以采用图的分割技术，将图分割成若干个联通子图，这些子图即是用户的聚类。还有一种方法是将图嵌入到高维向量空间中，这样就可以采用kmeans聚类方法做聚类了。有了用户的聚类就可以采用上面基于计数统计的直观方法做推荐了，或者采用更复杂的方案做推荐。")]),t._v(" "),s("p",[t._v("那怎么构建用户关系图呢？一般有两种方法。如果是社交类产品，可以基于社交关系来构建用户关系图，用户之间的边，代表好友关系。如果是非社交类产品，如果两个用户对同一标的物都有操作行为，那么这两个用户之间可以构建一条边。")]),t._v(" "),s("p",[t._v("群组个性化推荐的优势是每组给出一样的推荐，可以减少推荐的计算和存储。但该方案有一个最大的问题，同一组推荐一样的标的物列表，很可能对某个用户来说，推荐的标的物他已经看过，但是其他用户没有看过，所以无法过滤掉该标的物，针对某些用户推荐体验不够好。另外，同一组用户在兴趣特征上多少是有差别的，无法精细地照顾到每个用户的兴趣点。")]),t._v(" "),s("p",[t._v("群组个性化推荐的思路和优点也可以用于完全个性化范式的推荐。可以将用户先分组，每一个分组看成一个等价类(熟悉数学的同学应该很容易理解，不熟悉的同学可以理解为一个兴趣小组)，同一组的用户当成一个用户，这样就可以利用完全个性化范式中的算法思路来做推荐。Google在07年发表的一篇论文(参考文献17)就是采用该思路的协同过滤实现。将用户分组可以减少计算量，支持大规模并行计算。")]),t._v(" "),s("h3",{attrs:{id:"_4-标的物关联标的物范式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-标的物关联标的物范式"}},[t._v("#")]),t._v(" "),s("strong",[t._v("4. 标的物关联标的物范式")])]),t._v(" "),s("p",[t._v("标的物关联标的物就是为每个标的物推荐一组标的物。该推荐范式的核心是怎么从一个标的物关联到一组标的物。这种关联关系可以是相似的，也可以是基于其他维度的关联。常用的推荐策略是相似推荐。下面给出4种常用的生成关联推荐的策略。")]),t._v(" "),s("h4",{attrs:{id:"_1-基于内容的推荐"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-基于内容的推荐"}},[t._v("#")]),t._v(" "),s("strong",[t._v("（1）基于内容的推荐")])]),t._v(" "),s("p",[t._v("这类方法一般可以利用已知的数据和信息利用向量来描述标的物，如果每个标的物都被向量化了，那么我们就可以利用向量之间的相似度来计算标的物之间的相似度。")]),t._v(" "),s("p",[t._v("如果标的物是新闻等文本信息，可以采用TF-IDF将标的物映射为词向量，我们可以通过词向量的相似度来计算标的物之间的相似度。")]),t._v(" "),s("p",[t._v("即使不是文本，只要标的物具备metadata等文本信息，也可以采用该方法。很多互联网产品是具备用户评论功能的，这些评论文本就可以看成是标的物的描述信息。")]),t._v(" "),s("p",[t._v("LDA模型也非常适合文本类的推荐，通过LDA模型将文章(文档)表示为主题及相关词的概率，我们可以通过如下方式计算两个文档的相似度：先计算两个文档某个主题的相似度，将所有主题的相似度加权平均就可以得到两篇文档的相似度，而主题的相似度可以采用主题的词向量的余弦内积来表示。")]),t._v(" "),s("h4",{attrs:{id:"_2-基于用户行为的推荐"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-基于用户行为的推荐"}},[t._v("#")]),t._v(" "),s("strong",[t._v("（2）基于用户行为的推荐")])]),t._v(" "),s("p",[t._v("在一个成熟的推荐产品中，会包含很多用户的行为，如用户的收藏、点赞、购买、播放、浏览、搜索等，这些行为代表了用户对标的物的某种偏好。我们可以基于该用户行为来进行关联推荐。具体的策略有如下4类。")]),t._v(" "),s("ul",[s("li",[t._v("a 比如常用的矩阵分解算法")])]),t._v(" "),s("p",[t._v("可以将用户的行为矩阵分解为用户特征矩阵和物品特征矩阵，物品特征矩阵可以看成是衡量物品的一个向量，利用该向量我们就可以计算两个标的物之间的相似度了。")]),t._v(" "),s("ul",[s("li",[t._v("b 采用嵌入的思路做推荐")])]),t._v(" "),s("p",[t._v("用户的所有行为可以看成是一个文档，每个标的物可以看成是一个词，我们可以采用类似word2vec的思路，最终训练出每个词(即标的物)的向量表示，利用该向量表示可以计算标的物之间的相似度。")]),t._v(" "),s("ul",[s("li",[t._v("c 我们可以将用户对标的物的所有操作行为投射到一个二维表(或者矩阵)上")])]),t._v(" "),s("p",[t._v("行是用户，列是标的物，表中的元素就是用户对该标的物的操作(评分或者点击等隐式行为)，通过这种方式我们就构建了一个二维表。这个二维表的列向量就可以用来表示标的物。这样我们就可以采用向量相似来计算标的物之间的相似度了。")]),t._v(" "),s("ul",[s("li",[t._v("d 采用购物篮的思路做推荐，这种思路非常适合图书、电商等的推荐")])]),t._v(" "),s("p",[t._v("经常一起购买(或者浏览)的标的物形成一个列表(一个购物篮)，将过去一段时间所有的购物篮收集起来。 任何一个标的物，我们可以找到跟它出现在同一个购物篮的标的物及次数，统计完该次数后，我们就可以按照该次数降序排列，那么这个列表就可以当做标的物的关联推荐了。该推荐思路非常直观易懂，可解释性强。下面图就是亚马逊网站上采用该思路的两类关联推荐。")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/20200516191642860.png"),alt:"wxmp"}}),t._v(" "),s("h3",{attrs:{id:"_3-基于标签推荐"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-基于标签推荐"}},[t._v("#")]),t._v(" "),s("strong",[t._v("（3） 基于标签推荐")])]),t._v(" "),s("p",[t._v("如果标的物是包含标签的，比如视频推荐。我们就可以利用标签来构建向量，每个标签代表一个维度。总标签的个数就是向量的维度，这样每个标的物就可以利用标签的向量来表示了。一般标的物的标签个数远远小于总标签的个数，所以这个向量是稀疏向量。这样我们就可以基于稀疏向量的表示来计算标的物之间的相似度了。")]),t._v(" "),s("h3",{attrs:{id:"_4-基于标的物聚类的推荐"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-基于标的物聚类的推荐"}},[t._v("#")]),t._v(" "),s("strong",[t._v("（4）基于标的物聚类的推荐")])]),t._v(" "),s("p",[t._v("我们可以将标的物按照某个维度聚类，同一类具备某些相似性，那么我们在推荐时，就可以将同一类的其他标的物作为关联推荐。我们需要解决的问题是，某些类可能数量很小，不够做推荐，这时可以采用一些策略来补充(如补充热门推荐等)不足的数量。")]),t._v(" "),s("h3",{attrs:{id:"_5-笛卡尔积范式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-笛卡尔积范式"}},[t._v("#")]),t._v(" "),s("strong",[t._v("5. 笛卡尔积范式")])]),t._v(" "),s("p",[t._v("笛卡尔积范式的推荐算法一般可以先采用标的物关联标的物范式计算出待推荐的标的物列表。再根据用户的兴趣来对该推荐列表做重排(调整标的物列表的顺序)、增补(增加用户的个性化兴趣)、删除(比如过滤掉用户看过的)等。由于笛卡尔积范式的推荐算法在真实业务场景中使用不多，这里不再详细讲解。")]),t._v(" "),s("p",[t._v("到目前为止，我们讲完了常用的召回策略。召回除了根据上面的一些算法策略外，还跟具体业务及产品形态有关，可以基于更多的其他维度(如时间、地点、用户属性、收入、职业等)来做召回。")]),t._v(" "),s("p",[t._v("智能电视上的推荐，早上、白天、晚上推荐的不一样，节假日和平常推荐的也不一样。上班族早上需要上班，时间不充足，可能推荐短视频或者新闻更加合适，白天一般是老人在家，可以推荐戏曲、抗战类节目等，晚上主人回家又会推荐不一样的内容。")]),t._v(" "),s("p",[t._v("基于地点的召回，要求在不同的地方推荐不一样的标的物，典型的应用有美团外卖，你在不同的地方，给你推荐的是你所在地附近几公里范围内的餐厅。")]),t._v(" "),s("h3",{attrs:{id:"个性化召回算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#个性化召回算法"}},[t._v("#")]),t._v(" 个性化召回算法")]),t._v(" "),s("p",[t._v("本章节主要讲解itemcf与usercf的基础理论部分与理论公式升级部分，并详细介绍itemcf与usercf的优缺点分析")]),t._v(" "),s("p",[t._v("Item Collaborative Filtering(Item CF)\n背景")]),t._v(" "),s("ul",[s("li",[t._v("信息过载，用户需求不明确")]),t._v(" "),s("li",[t._v("强依赖于用户行为")])]),t._v(" "),s("p",[t._v("工业界主流落地场景")]),t._v(" "),s("ul",[s("li",[t._v("信息流")]),t._v(" "),s("li",[t._v("电商")]),t._v(" "),s("li",[t._v("o2oLBS")])]),t._v(" "),s("p",[t._v("含义：给用户推荐他之前喜欢的物品相似的物品")]),t._v(" "),s("p",[t._v("如何衡量相似")]),t._v(" "),s("ul",[s("li",[t._v("基于用户行为，如果喜欢2个物品的用户重合度越高，那么2个物品也就越相似。\n如何衡量喜欢")]),t._v(" "),s("li",[t._v("看用户是否真实点击，在电商场景下，更看重实际转化（实际消费购买）；信息流场景下，更看重真实的点击（基于一定时长下的停留）")])]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/20200516194314129.png"),alt:"wxmp"}}),t._v(" "),s("p",[t._v("物品之间相似度公式：")]),t._v(" "),s("ul",[s("li",[t._v("更多公式信息，可以参见原文\n"),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetailx-1.png"),alt:"wxmp"}})])]),t._v(" "),s("h3",{attrs:{id:"item-cf在工业界落地公式升级1"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#item-cf在工业界落地公式升级1"}},[t._v("#")]),t._v(" "),s("strong",[t._v("Item CF在工业界落地公式升级1")]),t._v("：")]),t._v(" "),s("p",[t._v("理论意义：针对于活跃用户应该被降低在相似度公式中的贡献度。")]),t._v(" "),s("p",[t._v("如果在某电商系统中，如果某User A是批发商，他购买了很多物品，可能有啤酒，书刊等，这都不能真实的表现他的兴趣。还有一名User B,他只买了啤酒和书刊，这能完全表现他的兴趣。如果我们在计算啤酒和书刊的相似度的时候，如果按照之前相似度公式User A和User B对啤酒和书刊的相似度贡献是一样的。这样子显然是不合理的。我们需要降低User A在相似度计算过程中的贡献度。")]),t._v(" "),s("ul",[s("li",[t._v("更多公式信息，可以参见原文\n"),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetailx-2.png"),alt:"wxmp"}})])]),t._v(" "),s("p",[t._v("与之前的相似度计算公式公式相比，分母部门没有发生任何变化。那么我们重点看分子部分。之前的相似度计算公式中每个重合用户对相似度的贡献是一样的，都是1.但是升级后的公式，我们发现每个用户对相似度的贡献变成了不一样。N(u)表示用户u所行为过的item的总数。如果一个用户行为过的item的总数越多，那么他的相似度就越低。这样子是符合常理的认知的。")]),t._v(" "),s("p",[t._v("分子：N(u)表示用户u所行为过的item总数，如果用户行为过的总数越多，对相似度贡献越低。")]),t._v(" "),s("h3",{attrs:{id:"item-cf在工业界落地公式升级2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#item-cf在工业界落地公式升级2"}},[t._v("#")]),t._v(" "),s("strong",[t._v("Item CF在工业界落地公式升级2")]),t._v("：")]),t._v(" "),s("p",[t._v("理论意义：用户在不同时间对item的操作应给予时间衰减惩罚。")]),t._v(" "),s("p",[t._v("因为在很多场景中，用户的兴趣随时间是有变化的。如在信息流场景中，可能30前看过的短视频，30天后就不一定喜欢了。因为在做物品相似度矩阵计算的时候，就假定了用户的行为可以反映用户的兴趣。所以需要给予时间衰减降权。")]),t._v(" "),s("ul",[s("li",[t._v("更多公式信息，可以参见原文\n"),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetailx-3.png"),alt:"wxmp"}})])]),t._v(" "),s("p",[t._v("与之前的相似度计算公式相比，分母部门没有发生任何变化。那么我们重点看分子部分。每个用户对相似度的贡献也发生了变化。这里的变化主要由Δ t \\Delta tΔ"),s("em",[t._v("t")]),t._v("决定的。Δ t \\Delta tΔ"),s("em",[t._v("t")]),t._v("是指用户item i与 item j所行为的时间的差异。")]),t._v(" "),s("h3",{attrs:{id:"user-collaborative-filtering-user-cf"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#user-collaborative-filtering-user-cf"}},[t._v("#")]),t._v(" "),s("strong",[t._v("User Collaborative Filtering(User CF)")])]),t._v(" "),s("p",[t._v("意义：给用户推荐相似兴趣用户感兴趣的物品。")]),t._v(" "),s("p",[t._v("举个栗子：在我们读书的时候是否经常问学长学姐该读什么样的书或者下载什么样的论文？学长学姐就会给你推荐。在这个栗子中学长学姐和你就属于具有相同爱好的用户群体，因为你们具有相同的研究领域。")]),t._v(" "),s("p",[t._v("那么所以基于用户的协同过滤的算法有两个步骤：")]),t._v(" "),s("p",[t._v("1、找到相似兴趣用户的集合")]),t._v(" "),s("p",[t._v("那么问题来了，如何评价相似兴趣用户集合？区别于很多传统做法，这里主要采用基于用户行为重合度的方法，举例来说，如果两个用户的行为具有很高的重合度，那么他们具有很高的相似性。那么他们可以称为相似兴趣用户集合。")]),t._v(" "),s("p",[t._v("2、推荐相似用户行为过，而该用户并没有行为过的item。举个栗子，如果我们发现两个用户A、B都非常喜欢足球相关的视频，行为重合度极高。而用户B经常点击天下足球相关的视频，用户A并没有行为，那么我们可以推荐天下足球相关的视频给用户A。")]),t._v(" "),s("p",[t._v("栗子：")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/20200516194725504.png"),alt:"wxmp"}}),t._v(" "),s("p",[t._v("User A 可以给User D 推荐b")]),t._v(" "),s("p",[t._v("基于用户的协同过滤算法的步骤")]),t._v(" "),s("p",[t._v("1、计算相似用户的相似度矩阵")]),t._v(" "),s("p",[t._v("相似度公式")]),t._v(" "),s("ul",[s("li",[t._v("更多公式信息，可以参见原文\n"),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetailx-4.png"),alt:"wxmp"}})])]),t._v(" "),s("p",[t._v("N(u)表示用户u有过行为item的集合。N(v)表示用户v有过行为item的集合。")]),t._v(" "),s("p",[t._v("分子是item的重合程度。显然重合程度越高，user越相似。")]),t._v(" "),s("p",[t._v("分母做了一个归一化，物理意义上解释了惩罚了操作过多的用户与其他用户的相似程度。因为操作过多的用户对应的item的序列会非常的长，造成了与很多的用户都有相似。分母除以一个很大的数之后呢，就能把相似度得分的数值趋于0.在得到用户相似度矩阵过后，我们根据用户的行为点击，来完成相似用户的item推荐。")]),t._v(" "),s("p",[t._v("下面来看公式")]),t._v(" "),s("ul",[s("li",[t._v("更多公式信息，可以参见原文\n"),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetailx-5.png"),alt:"wxmp"}})])]),t._v(" "),s("p",[s("code",[t._v("$S_{u v} $")]),t._v("表示user u与uer v的相似度得分。这里根据用户v来完成对用户u的推荐。所以这里要介绍用户v。用户v是用户u的前TOP k个的相似用户。并且用户v行为过的物品 item i,用户user u 没有行为。那么我们便得到了用户u对item i的推荐度得分。")]),t._v(" "),s("h3",{attrs:{id:"工业界落地时公式升级1"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#工业界落地时公式升级1"}},[t._v("#")]),t._v(" "),s("strong",[t._v("工业界落地时公式升级1")]),t._v(":")]),t._v(" "),s("p",[t._v("理论意义：降低那些异常活跃物品对与用户相似度的贡献")]),t._v(" "),s("p",[t._v("举个栗子解释：")]),t._v(" "),s("p",[t._v("如果某个电商系统中，User (A) 与User(B)同时购买了《新华字典》，User (A) 与User©同时购买了《机器学习》，并且他们都只有这一本书重合，User (A) 与User(B)、User (A) 与User©的重合度都是1，显然不合理，因为购买《新华字典》并不能十分准确的反映用户的兴趣，也许是给家里孩子买，换言之《新华字典》的用户倒排会非常的长，而购买《机器学习》的用户大概率可以反映他们的兴趣，因为这本书的购书群体很窄，因此我们需要降低那些很多人购买的在重合度中的贡献。")]),t._v(" "),s("ul",[s("li",[t._v("更多公式信息，可以参见原文\n"),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetailx-6.png"),alt:"wxmp"}})])]),t._v(" "),s("p",[t._v("分子：基础版本的相似度计算公式当中重合的每一item对整体的贡献都是相同的。在升级版中贡献变得不同的。u(i)表示对item(i)有过行为的用户集合，如果一个item被更多的用户行为过，那么它在重合度的贡献越低。这也符合我们的认知。")]),t._v(" "),s("h3",{attrs:{id:"公式升级2-工业界"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#公式升级2-工业界"}},[t._v("#")]),t._v(" "),s("strong",[t._v("公式升级2（工业界）")])]),t._v(" "),s("p",[t._v("理论意义，不同用户对同一item行为的时间段不同应该给予时间惩罚\n（因为很多用户不同时间段，兴趣是发生变化的，比如，2个用户都曾经点击过足球类短视频，一个用户是近期点击，另一个用户是在好几个月之前欧洲杯比赛期间，也许在目前时间节点，已经不再喜欢足球类短视频了，我们在计算用户相似度矩阵的时候，假定了用户行为可以反映出用户的兴趣，所以我们要给予时间衰减降权）")]),t._v(" "),s("ul",[s("li",[t._v("更多公式信息，可以参见原文\n"),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetailx-7.png"),alt:"wxmp"}})])]),t._v(" "),s("h3",{attrs:{id:"itemcf-vs-usercf优缺点比较"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#itemcf-vs-usercf优缺点比较"}},[t._v("#")]),t._v(" "),s("strong",[t._v("Itemcf VS Usercf")]),t._v("优缺点比较：")]),t._v(" "),s("h4",{attrs:{id:"推荐实时性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#推荐实时性"}},[t._v("#")]),t._v(" 推荐实时性")]),t._v(" "),s("ul",[s("li",[t._v("User cf用户有了新的行为，不会对结果造成很快的变化，因为Usercf是基于相似度矩阵来完成推荐的，User本身的行为并不能造成自己的推荐结果发生改变。")]),t._v(" "),s("li",[t._v("Item cf用户一旦有了新的行为，推荐结果立刻发生改变，因为Itemcf是基于相似度矩阵来完成推荐的，所以点击了物品，会立马推荐出相似的物品")])]),t._v(" "),s("h4",{attrs:{id:"新用户-新物品的推荐"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#新用户-新物品的推荐"}},[t._v("#")]),t._v(" 新用户/新物品的推荐")]),t._v(" "),s("ul",[s("li",[t._v("Usercf新用户的到来是不能立即推荐的，需要等用户有了一定的行为并且得到了与其他用户相似度矩阵之后才可以完成推荐，新用户一旦被用户点击，Usercf可以通过相似度用户矩阵将该物品推荐给相似的用户。")]),t._v(" "),s("li",[t._v("Item cf新用户一旦完成了Item点击，便可以推荐该Item相似的其余Item，新物品的到来，由于此时新物品，并没有与其他物品在相似度矩阵中出现，所以Itemcf并不能将新物品及时地推荐出去")])]),t._v(" "),s("h3",{attrs:{id:"推荐理由的可解释性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#推荐理由的可解释性"}},[t._v("#")]),t._v(" 推荐理由的可解释性")]),t._v(" "),s("ul",[s("li",[t._v("User cf由于是通过用户相似度矩阵来完成推荐的，结果会略显难以解释。")]),t._v(" "),s("li",[t._v("Item cf通过用户历史点击行为完成的推荐，所以推荐结果更加令人信服。")])]),t._v(" "),s("h3",{attrs:{id:"item-cf-vs-user-cf适用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#item-cf-vs-user-cf适用场景"}},[t._v("#")]),t._v(" "),s("strong",[t._v("Item cf VS User cf适用场景")])]),t._v(" "),s("h4",{attrs:{id:"性能层面考量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#性能层面考量"}},[t._v("#")]),t._v(" 性能层面考量")]),t._v(" "),s("ul",[s("li",[t._v("User cf通过计算用户相似度矩阵，所以它并不适合用户很多的场合。因为相似度矩阵计算起来代价非常大。")]),t._v(" "),s("li",[t._v("Item cf需要计算物品的相似度矩阵，所以Itemcf适用于物品数远小于用户数场合。由于实战中用户量往往远大于物品的数量级，所以实战中更倾向于Item cf。")])]),t._v(" "),s("h4",{attrs:{id:"个性化层面考量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#个性化层面考量"}},[t._v("#")]),t._v(" 个性化层面考量")]),t._v(" "),s("ul",[s("li",[t._v("User cf适用于物品及时推荐下发且个性化需求不太强烈的领域。")]),t._v(" "),s("li",[t._v("Itemcf适用于长尾物品丰富并且个性化需要强烈的领域。由于真实的推荐系统中，各种个性化召回算法组合，会有一些召回方法解决新物品及时下发问题，而我们需要个性化程度强烈，所以从个性化层面考虑，更倾向于在落地实战中采用Itemcf。")])]),t._v(" "),s("h4",{attrs:{id:"itemcf的优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#itemcf的优势"}},[t._v("#")]),t._v(" ItemCF的优势：")]),t._v(" "),s("p",[t._v("（1）计算性能高，通常用户数量远大于物品数量。")]),t._v(" "),s("p",[t._v("（2）可预先计算保留，物品并不善变。")]),t._v(" "),s("h4",{attrs:{id:"itemcf存在的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#itemcf存在的问题"}},[t._v("#")]),t._v(" ItemCF存在的问题：")]),t._v(" "),s("p",[t._v("物品冷启动问题：当平台中物品数据较少或缺失时，无法精确计算物品相似度，解决办法：")]),t._v(" "),s("p",[t._v("（1）文本分析，通过分析物品的介绍文本，计算相似度。\n（2）主题模型，通过主题模型分析物品文本主题得出主题相似度。\n（3）打标签，对物品打标签求得相似度。\n（4）推荐排行榜单。")]),t._v(" "),s("h2",{attrs:{id:"三、排序算法概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、排序算法概述"}},[t._v("#")]),t._v(" 三、排序算法概述")]),t._v(" "),s("p",[t._v("推荐系统排序模块将召回模块产生的标的物列表(一般几百个标的物)，通过排序算法做重排，更好的反应用户的点击偏好，通过排序优化用户的点击行为，将用户更可能点击的标的物(一般几十个)取出来推荐给用户，最终提升用户体验。")]),t._v(" "),s("p",[t._v("排序模块会用到很多特征，基于这些特征构建排序模型，排序特征在排序的效果中起到非常关键的作用，常用的特征可以抽象为如下5大类：")]),t._v(" "),s("ul",[s("li",[t._v("用户侧的特征，如用户的性别、年龄、地域、购买力、家庭结构等。")]),t._v(" "),s("li",[t._v("商品侧的特征，如商品描述信息、价格、标签等。")]),t._v(" "),s("li",[t._v("上下文及场景特征，如位置、页面、是否是周末节假日等。")]),t._v(" "),s("li",[t._v("交叉特征，如用户侧特征与商品侧特征的交叉等。")]),t._v(" "),s("li",[t._v("用户的行为特征，如用户点击、收藏、购买、观看等。")])]),t._v(" "),s("p",[t._v("包括：个性化召回算法、个性化排序算法")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/20200516192913640.png"),alt:"wxmp"}}),t._v(" "),s("p",[t._v("排序框架需要充分利用上述五大类特征，以便更好的预测用户的点击行为。排序学习是机器学习中一个重要的研究领域，广泛应用于信息检索、搜索引擎、推荐系统、计算广告等的排序任务中，有兴趣的读者可以参考微软亚洲研究院刘铁岩博士的专著《Learning to Rank for Information Retrieval》。常用的排序算法框架有pointwise、pairwise、listwise三类，见下图。")]),t._v(" "),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/20200516192307472.png"),alt:"wxmp"}}),t._v(" "),s("p",[t._v("上图中x1，x2，… 代表的是训练样本1，2，… 的特征，y1，y2，s1，… 等是训练集的label(目标函数值)。pointwise学习单个样本，如果最终预测目标是一个实数值，就是回归问题，如果目标是概率预测，就是一个分类问题，例如CTR预估。pairwise和listwise分别学习一对有序对和一个有序序列的样本特征，考虑得更加精细。在推荐系统中常用pointwise方法来做排序，它更直观，易于理解，也更简单。")]),t._v(" "),s("p",[t._v("常用的排序学习算法有logistic回归、GBDT、Wide & Deep等，这里对这些算法的实现原理做一个简单描述。")]),t._v(" "),s("h3",{attrs:{id:"_1-logistic回归模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-logistic回归模型"}},[t._v("#")]),t._v(" "),s("strong",[t._v("1. logistic回归模型")])]),t._v(" "),s("p",[t._v("logistic回归是比较简单的线性模型，通过学习用户点击行为来构建CTR预估。利用logistic回归构建推荐算法模型，具体模型如下面公式。")]),t._v(" "),s("ul",[s("li",[t._v("更多公式信息，可以参见原文\n"),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetailx-8.png"),alt:"wxmp"}})])]),t._v(" "),s("p",[t._v("我们可以通过上述公式计算待推荐标的物的p值。最终我们可以按照p值的大小降序排列来对召回的标的物列表做排序。")]),t._v(" "),s("p",[t._v("在工业界，为了更好地将该模型应用到真实业务场景中，很多公司对logistic回归模型做了推广。比如用到在线实时推荐场景中做排序，有Google在2013年推广的FTRL(见参考文献14)，以及阿里推广的分片线性模型(见参考文献13)。")]),t._v(" "),s("h3",{attrs:{id:"_2-gbdt模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-gbdt模型"}},[t._v("#")]),t._v(" "),s("strong",[t._v("2. GBDT模型")])]),t._v(" "),s("p",[t._v("GBDT(Gradient Boosting Decision Tree)是一种基于迭代思路构造的决策树算法(可以参考文献15)，该算法在实际问题中将生成多棵决策树，并将所有树的结果进行汇总来得到最终答案，该算法将决策树与集成思想进行了有效的结合，通过将弱学习器提升为强学习器的集成方法来提高预测精度。GBDT是一类泛化能力较强的学习算法。")]),t._v(" "),s("p",[t._v("2014年Facebook发表了一篇介绍将GBDT+LR(Logistic Regression)模型用于其广告CTR预估的论文(参考文献16)，开启了利用GBDT模型应用于搜索、推荐、广告业务的先河。GBDT作为一种常用的树模型，可天然地对原始特征进行特征划分、特征组合和特征选择，并得到高阶特征属性和非线性映射。从而可将GBDT模型抽象为一个特征处理器，通过GBDT分析原始特征获取到更利于LR分析的新特征，这也正是GBDT+LR模型的核心思想——利用GBDT构造的新特征来训练LR模型。")]),t._v(" "),s("h3",{attrs:{id:"_3-wide-deep模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-wide-deep模型"}},[t._v("#")]),t._v(" "),s("strong",[t._v("3. Wide & deep模型")])]),t._v(" "),s("p",[t._v("Wide&deep模型最早被Google提出来，并用于Android手机应用商店上APP的推荐排序。目前该算法在国内很多互联网企业得到大规模的采用，有比较好的效果。该模型将传统模型和深度学习模型相结合。wide部分(传统模型，如logistic回归)起记忆(memorization)的作用，即从历史数据中发现item(推荐内容)或者特征之间的相关性，deep部分(深度学习模型)起泛化(generalization)的作用，即相关性的传递，发现在历史数据中很少或者没有出现的新的特征组合，寻找用户的新偏好。通过将这两个模型结合起来可以更好地在用户的历史兴趣和探索新的兴趣点之间做到平衡。感兴趣的读者可以阅读参考文献12。")]),t._v(" "),s("p",[t._v("评估指标：\n包括：在线评估指标和离线评估指标\n"),s("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/ac/rsintro/algorithmdetail/20200516193047968.png"),alt:"wxmp"}})]),t._v(" "),s("h2",{attrs:{id:"四、推荐算法落地需要关注的几个问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、推荐算法落地需要关注的几个问题"}},[t._v("#")]),t._v(" 四、推荐算法落地需要关注的几个问题")]),t._v(" "),s("p",[t._v("前面几节对推荐系统算法和产品做了初步描述，相信大家对常用算法实现思路、怎么用于真实产品中有了比较直观的认识。在本节作者对算法落地中几个重要问题加以说明，以便你可以更好地将推荐算法落地到真实业务场景中。")]),t._v(" "),s("h3",{attrs:{id:"_1-推荐算法工程落地是否一定需要排序模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-推荐算法工程落地是否一定需要排序模块"}},[t._v("#")]),t._v(" 1. 推荐算法工程落地是否一定需要排序模块")]),t._v(" "),s("p",[t._v("工业上的推荐算法一般分为召回和排序模块，召回的作用是从全量标的物集合(几万甚至上亿)中将用户可能喜欢的标的物取出来(几百个)，排序阶段将召回的标的物集按照用户点击的可能性再做一次排序。但是排序阶段不是必须的，特别是对于标的物池不大的产品及团队资源较少的情形，没必要一开始就开发出排序框架。召回算法一般也会对标的物做排序(如果是评分预测模型，如矩阵分解，可以按照评分大小排序，如果是概率模型，可以按照对标的物的偏好概率大小排序)。缺失了排序模块的推荐系统可能精准度没有那么高，但是工程实现上相对更加简单，可以快速落地上线。特别对于刚做推荐系统的团队，可以让系统快速上线，后面再逐步迭代，补全缺失模块。")]),t._v(" "),s("h3",{attrs:{id:"_2-推荐算法服务于用户的两种形式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-推荐算法服务于用户的两种形式"}},[t._v("#")]),t._v(" 2. 推荐算法服务于用户的两种形式")]),t._v(" "),s("p",[t._v("推荐算法计算出的推荐结果可以直接插入数据库(如Redis等)，直接为用户提供服务，另外一种方式是将核心特征计算好存储下来，当用户请求推荐业务时，推荐web服务通过简单计算将特征转化为最终给用户的推荐结果返回给用户。这两种方式一个是事先计算好，拿来就用，另外一种是准备好核心数据，在请求时实时计算最终结果。")]),t._v(" "),s("p",[t._v("我拿餐厅服务外卖来类比说明，第一种方式是将餐厅有的菜先做好很多份，如果有外卖单过来，直接将做好的送出。第二种是将所有的配菜都准备好，接到外卖单立马将配菜加上调料炒熟再送出去，只要配菜准备足够好，炒菜的时间不太长并且可控，也是可以很好的服务用户的。第一种方式是事先做好的，无法满足用户个性化需求，同时如果做好了没人点的话就浪费了，第二种可以更好满足用户个性化需求，比如用户说不要香菜多放辣椒就可以在现做的时候满足。")]),t._v(" "),s("p",[t._v("第二种方式对整个推荐系统要求更高，服务更加精细，但是第一种方案更加简单，不过也需要更多的存储资源(将所有用户的推荐结果事先存下来)。在推荐系统构建的初级阶段建议采用方案一。")]),t._v(" "),s("p",[t._v("某些推荐业务用方案一是不可行的，比如上面的笛卡尔积范式的推荐系统，因为用户数乘以标的物数是一个巨大的天文数字，公司不可能有这么多的资源将每个用户关联的每个标的物的推荐结果事先计算好存储下来。")]),t._v(" "),s("h3",{attrs:{id:"_3-推荐系统评估"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-推荐系统评估"}},[t._v("#")]),t._v(" 3. 推荐系统评估")]),t._v(" "),s("p",[t._v("推荐系统是服务于公司商业目标的(盈利目标，提升用户体验、使用时长、DAU等，最终也是为了盈利)，所以推荐系统落地到真实业务场景中一定要定义推荐系统的优化目标，只有目标具体而清晰，并可量化，才能更好的通过不断迭代优化推荐效果。大家可以参考《推荐系统的商业价值》，了解怎么定义推荐系统的商业指标。")]),t._v(" "),s("p",[t._v("参考文献：")]),t._v(" "),s("ul",[s("li",[t._v("1.Multi-Interest Network with Dynamic Routing for Recommendation at Tmall")]),t._v(" "),s("li",[t._v("2.Deep Session Interest Network for Click-Through Rate Prediction")]),t._v(" "),s("li",[t._v("3.Behavior Sequence Transformer for E-commerce Recommendation in Alibaba")]),t._v(" "),s("li",[t._v("4.Billion-scale Commodity Embedding for E-commerce Recommendation in Alibaba")]),t._v(" "),s("li",[t._v("5.Personal Recommendation Using Deep Recurrent Neural Networks in NetEase")]),t._v(" "),s("li",[t._v("6.Deep Reinforcement Learning for List-wise Recommendations")]),t._v(" "),s("li",[t._v("7.Recommendations with Negative Feedback via Pairwise Deep Reinforcement Learning")]),t._v(" "),s("li",[t._v("8.Learning Tree-based Deep Model for Recommender Systems")]),t._v(" "),s("li",[t._v("9.Item2Vec- Neural Item Embedding for Collaborative Filtering")]),t._v(" "),s("li",[t._v("10.Deep Neural Networks for YouTube Recommendations")]),t._v(" "),s("li",[t._v("11.Deep Learning based Recommender System- A Survey and New Perspectives")]),t._v(" "),s("li",[t._v("12.Wide & Deep Learning for Recommender Systems")]),t._v(" "),s("li",[t._v("13.Learning Piece-wise Linear Models from Large Scale Data for Ad Click Prediction")]),t._v(" "),s("li",[t._v("14.Ad Click Prediction- a View from the Trenches")]),t._v(" "),s("li",[t._v("15.Greedy function approximation: a gradient boosting machine")]),t._v(" "),s("li",[t._v("16.Practical Lessons from Predicting Clicks on Ads at Facebook")]),t._v(" "),s("li",[t._v("17.Google News Personalization: Scalable Online Collaborative Filtering")])]),t._v(" "),s("h2",{attrs:{id:"参考文章"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章")]),t._v(" "),s("ul",[s("li",[t._v("https://blog.csdn.net/weixin_44023658/article/details/106162732")])])])}),[],!1,null,null,null);a.default=v.exports}}]);