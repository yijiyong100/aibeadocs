(window.webpackJsonp=window.webpackJsonp||[]).push([[438],{953:function(a,t,r){"use strict";r.r(t);var s=r(53),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),r("p",[a._v("本文主要是介绍 Yarn-运行机制原理 。")])]),a._v(" "),r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#yarn框架原理及运行机制"}},[a._v("YARN框架原理及运行机制")]),r("ul",[r("li",[r("a",{attrs:{href:"#一、yarn基本组成结构"}},[a._v("一、YARN基本组成结构")])]),r("li",[r("a",{attrs:{href:"#_1、resourcemanager-rm"}},[a._v("1、ResourceManager（RM）")])]),r("li",[r("a",{attrs:{href:"#_2、applicationmaster-am"}},[a._v("2、ApplicationMaster（AM）")])]),r("li",[r("a",{attrs:{href:"#_3、nodemanager-nm"}},[a._v("3、NodeManager（NM）")])]),r("li",[r("a",{attrs:{href:"#_4、container"}},[a._v("4、Container")])])])]),r("li",[r("a",{attrs:{href:"#二、yarn工作流程"}},[a._v("二、YARN工作流程")]),r("ul",[r("li",[r("a",{attrs:{href:"#三、yarn调度机制"}},[a._v("三、YARN调度机制")])]),r("li",[r("a",{attrs:{href:"#_1、capacity-scheduler"}},[a._v("1、capacity scheduler")])]),r("li",[r("a",{attrs:{href:"#_2、fair-scheduler"}},[a._v("2、fair scheduler")])])])]),r("li",[r("a",{attrs:{href:"#参考文章"}},[a._v("参考文章")])])])]),r("p"),a._v(" "),r("h2",{attrs:{id:"yarn框架原理及运行机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#yarn框架原理及运行机制"}},[a._v("#")]),a._v(" YARN框架原理及运行机制")]),a._v(" "),r("p",[a._v("YARN是Hadoop2.0中的资源管理系统，它的设计思想是将MRv1中的JobTracker拆分成两个独立的服务：一个全局的资源管理器ResourceManager和每个应用程序持有的ApplicationMaster。其中RM负责整个系统的资源管理和分配，AM负责单个应用程序的管理。")]),a._v(" "),r("h3",{attrs:{id:"一、yarn基本组成结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、yarn基本组成结构"}},[a._v("#")]),a._v(" 一、YARN基本组成结构")]),a._v(" "),r("p",[a._v("YARN总体上仍然是Master/Slaver结构，在整个资源管理框架中，RM为Master，NM为Slaver，RM负责对各个NM上的资源进行统一管理和调度。当提交一个应用程序时，需要提供一个用以跟踪和管理这个程序的AM，它负责向RM申请资源，并要求NM启动占用一定资源的任务，不同的AM被分布在不同的节点上。")]),a._v(" "),r("img",{staticClass:"zoom-custom-imgs",attrs:{src:a.$withBase("/assets/img/dp/yarn/runprin-1.png"),alt:"wxmp"}}),a._v(" "),r("h3",{attrs:{id:"_1、resourcemanager-rm"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、resourcemanager-rm"}},[a._v("#")]),a._v(" 1、ResourceManager（RM）")]),a._v(" "),r("p",[a._v("RM是一个全局的资源管理器，负责整个系统的资源管理和分配。主要由两个组件构成：调度器（Scheduler）和应用程序管理器（ASM）。")]),a._v(" "),r("h4",{attrs:{id:"_1-调度器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-调度器"}},[a._v("#")]),a._v(" （1）调度器")]),a._v(" "),r("p",[a._v("调度器根据容量、队列等限制条件（如每个队列分配一定的资源，最多执行一定数量的任务等，即调度策略），将系统中的资源分配给各个正在运行的程序。该调度器是“纯调度器”，它不再从事任何与具体应用程序相关的工作。调度器仅根据各个应用程序的资源需求进行资源分配，资源分配单位用一个抽象概念“资源容器（简称Container）”表示，Container将内存、CPU、磁盘、网络等资源封装在一起。")]),a._v(" "),r("h4",{attrs:{id:"_2-应用程序管理器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-应用程序管理器"}},[a._v("#")]),a._v(" （2）应用程序管理器")]),a._v(" "),r("p",[a._v("应用程序管理器负责管理整个系统中所有应用程序，包括应用程序提交、与调度器协商资源以启动AM、监控AM运行状态并在失败时重启程序等。")]),a._v(" "),r("h3",{attrs:{id:"_2、applicationmaster-am"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、applicationmaster-am"}},[a._v("#")]),a._v(" 2、ApplicationMaster（AM）")]),a._v(" "),r("p",[a._v("提交的每个应用程序包含一个AM，主要功能包括：")]),a._v(" "),r("p",[a._v("与RM调度器协商获取资源（用Container表示）；")]),a._v(" "),r("p",[a._v("为应用程序申请资源并分配给内部的任务；")]),a._v(" "),r("p",[a._v("与NM通信以启/停任务；")]),a._v(" "),r("p",[a._v("监控所有任务状态，并在任务失败时重新申请资源以重启任务；")]),a._v(" "),r("h3",{attrs:{id:"_3、nodemanager-nm"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、nodemanager-nm"}},[a._v("#")]),a._v(" 3、NodeManager（NM）")]),a._v(" "),r("p",[a._v("NM是每个节点上的资源和任务管理器，一方面，它会定时地向RM汇报本节点上的资源使用情况和各个Container的运行状态；另一方面，它接收并处理来自AM的Container启动/停止等各种请求。")]),a._v(" "),r("h3",{attrs:{id:"_4、container"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4、container"}},[a._v("#")]),a._v(" 4、Container")]),a._v(" "),r("p",[a._v("Container 是YARN中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等，当AM向RM申请资源时，RM为AM返回的资源便是用 Container表示的。YARN会为每个任务分配一个Container，且该任务只能使用该Container中的资源。")]),a._v(" "),r("h2",{attrs:{id:"二、yarn工作流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、yarn工作流程"}},[a._v("#")]),a._v(" 二、YARN工作流程")]),a._v(" "),r("img",{staticClass:"zoom-custom-imgs",attrs:{src:a.$withBase("/assets/img/dp/yarn/runprin-2.png"),alt:"wxmp"}}),a._v(" "),r("p",[a._v("1、向YARN提交应用程序；")]),a._v(" "),r("p",[a._v("2、RM分配第一个Container，并与对应的NM通信，要求它在这个Container启动应用程序的ApplicationMaster；")]),a._v(" "),r("p",[a._v("3、AM首先向RM注册，通过RM可以查看应用程序的运行状态，然后它将为各个任务申请资源，并监控它的运行状态，直至运行结束；")]),a._v(" "),r("p",[a._v("4、AM采用轮询的方式通过RPC协议向RM申请和领取资源；")]),a._v(" "),r("p",[a._v("5、一旦AM申请到资源后，便与对应的NM通信，要求它启动任务；")]),a._v(" "),r("p",[a._v("6、NM为任务设置好运行环境（包括环境变量、JAR包、二进制程序等）后，将任务启动命令写到一个脚本中，并通过运行该脚本启动任务；")]),a._v(" "),r("p",[a._v("7、各个任务通过RPC协议向AM汇报自己的状态和进度，以让AM随时掌握各个任务的运行状态，从而可以在任务失败时重启任务；")]),a._v(" "),r("p",[a._v("8、应用程序运行完成后，AM向RM注销并关闭自己。")]),a._v(" "),r("h3",{attrs:{id:"三、yarn调度机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三、yarn调度机制"}},[a._v("#")]),a._v(" 三、YARN调度机制")]),a._v(" "),r("p",[a._v("YARN默认使用的是最简单FIFO调度器，即一个default队列，所有用户共享，分配资源先到先得，没有优先级之分。YARN还有两种资源调度器，capacity scheduler和fair scheduler。")]),a._v(" "),r("img",{staticClass:"zoom-custom-imgs",attrs:{src:a.$withBase("/assets/img/dp/yarn/runprin-3.png"),alt:"wxmp"}}),a._v(" "),r("h3",{attrs:{id:"_1、capacity-scheduler"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、capacity-scheduler"}},[a._v("#")]),a._v(" 1、capacity scheduler")]),a._v(" "),r("p",[a._v("capacity scheduler调度器以队列为单位划分资源。一个个队列有独立的资源，队列的结构和资源是可以进行配置的。队列以分层方式组织资源，设计了多层级别的资源限制条件以更好的让多用户共享一个Hadoop集群，比如队列资源限制、用户资源限制、用户应用程序数目限制。队列里的应用以FIFO方式调度，每个队列可设定一定比例的资源最低保证和使用上限，同时，每个用户也可以设定一定的资源使用上限以防止资源滥用。而当一个队列的资源有剩余时，可暂时将剩余资源共享给其它队列。")]),a._v(" "),r("p",[a._v("capacity调度器具有以下几个特征：1）层次化的队列设计，保证子队列可以使用父队列设置的全部资源；2）容量保证，队列上都会设置一个资源的占比，保证每个队列都不会占用整个集群的资源；3）安全，每个队列严格的访问控制；4）弹性分配，空闲的资源可以被分配给任何队列；5）多租户使用，通过队列的容量限制，多个用户可以共享一个集群；6）操作性，yarn支持动态修改调整容量、权限等的分配，可以在运行时直接修改；7）基于资源的调度，协调不同资源需求的应用程序。")]),a._v(" "),r("h3",{attrs:{id:"_2、fair-scheduler"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、fair-scheduler"}},[a._v("#")]),a._v(" 2、fair scheduler")]),a._v(" "),r("p",[a._v("fair调度器的设计目标是为所有的应用分配公平的资源（对公平的定义可以通过参数来设置），公平调度可以在多个队列间工作。假设有两个用户A和B，他们分别拥有一个队列，当A启动一个job而B没有任务时，A会获得全部集群资源；当B启动一个job后，A的job会继续运行，不过一会儿之后两个任务会各自获得一半的集群资源；如果此时B再有第二个job并且其它job还在运行，则它和B的第一个job共享B这个队列资源，也就是B的两个job各自占用四分之一的集群资源，而A的job仍然占用一半的集群资源，结果就是资源最终在两个用户之间平等的共享，过程如下图所示：")]),a._v(" "),r("img",{staticClass:"zoom-custom-imgs",attrs:{src:a.$withBase("/assets/img/dp/yarn/runprin-4.png"),alt:"wxmp"}}),a._v(" "),r("p",[a._v("所有的队列都是root队列的子队列，fair调度器中的队列有一个权重属性，这个权重就是对公平的定义。每个队列内部扔可以有不同的调度策略，队列的默认调度策略可以通过顶级元素"),r("code",[a._v("<defaultQueueSchedulingPolicy>")]),a._v("进行配置，每个队列的调度策略可以被内部的"),r("code",[a._v("<schedulingPolicy>")]),a._v("元素覆盖。")]),a._v(" "),r("p",[a._v("当一个job提交到一个繁忙集群中的空队列时，job并不会马上执行，而是阻塞直到正在运行的job释放系统资源。为了使提交job的时间更具有预测性（可以设置等待的超时时间），fair调度器支持抢占。抢占就是允许调度器杀掉占用超过其应占份额资源队列的containers，这些containers资源便可分配到应该享有这些份额资源的队列中。需要注意抢占会降低集群的执行效率，因为被终止的containers需要被重新执行。")]),a._v(" "),r("h2",{attrs:{id:"参考文章"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[a._v("#")]),a._v(" 参考文章")]),a._v(" "),r("ul",[r("li",[a._v("https://www.cnblogs.com/firstsheng618/p/9829832.html")])])])}),[],!1,null,null,null);t.default=e.exports}}]);