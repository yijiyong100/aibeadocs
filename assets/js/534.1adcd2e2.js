(window.webpackJsonp=window.webpackJsonp||[]).push([[534],{1049:function(t,s,a){"use strict";a.r(s);var i=a(53),r=Object(i.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("本文主要是介绍 Netty-IO模型总结 。")])]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#深入了解netty-io模型"}},[t._v("深入了解Netty IO模型")]),a("ul",[a("li",[a("a",{attrs:{href:"#引言"}},[t._v("引言")])]),a("li",[a("a",{attrs:{href:"#名词概念"}},[t._v("名词概念")])]),a("li",[a("a",{attrs:{href:"#_5种io模型"}},[t._v("5种IO模型")])]),a("li",[a("a",{attrs:{href:"#io模型对比"}},[t._v("IO模型对比")])])])]),a("li",[a("a",{attrs:{href:"#参考文章"}},[t._v("参考文章")])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"深入了解netty-io模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深入了解netty-io模型"}},[t._v("#")]),t._v(" 深入了解Netty IO模型")]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"引言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引言"}},[t._v("#")]),t._v(" 引言")]),t._v(" "),a("p",[t._v("IO模型就是操作数据输入输出的方式，在Linux系统中有5大IO模型：阻塞式IO模型、非阻塞式IO模型、IO复用模型、信号驱动式IO模型、异步IO模型。 因为学习Netty必不可少的要了解IO多路复用模型，本篇是基础。")]),t._v(" "),a("h3",{attrs:{id:"名词概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#名词概念"}},[t._v("#")]),t._v(" 名词概念")]),t._v(" "),a("ul",[a("li",[t._v("阻塞：指向调用方，在调用结果返回之前，调用方线程会挂起，直到结果返回。")]),t._v(" "),a("li",[t._v("非阻塞：指向调用方，在调用结果返回之前，调用方线程会处理其他事情，不会阻塞。")]),t._v(" "),a("li",[t._v("同步：指向被调用方，被调用方得到结果后再返回给调用方。")]),t._v(" "),a("li",[t._v("异步：指向被调用方，被调用方先应答调用方，然后计算结果，最终通知并返回给调用方。")]),t._v(" "),a("li",[t._v("recvfrom函数：系统调用，经socket接收数据。")])]),t._v(" "),a("h3",{attrs:{id:"_5种io模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5种io模型"}},[t._v("#")]),t._v(" 5种IO模型")]),t._v(" "),a("h4",{attrs:{id:"_1、阻塞式io模型-blocking-i-o"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、阻塞式io模型-blocking-i-o"}},[t._v("#")]),t._v(" 1、阻塞式IO模型(blocking I/O)")]),t._v(" "),a("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/framework/netty/nettyio-1.png"),alt:"wxmp"}}),t._v(" "),a("p",[t._v("进程调用recvfrom函数，在数据没有返回之前，进程阻塞，直到数据返回后，才会处理数据。")]),t._v(" "),a("h4",{attrs:{id:"_2、非阻塞式io模型-non-blocking-i-o"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、非阻塞式io模型-non-blocking-i-o"}},[t._v("#")]),t._v(" 2、非阻塞式IO模型(non-blocking I/O)")]),t._v(" "),a("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/framework/netty/nettyio-2.png"),alt:"wxmp"}}),t._v(" "),a("p",[t._v("进程调用recvfrom函数，如果数据没有准备好就返回错误提示，之后进程循环调用recvfrom函数，直到有数据返回。")]),t._v(" "),a("h4",{attrs:{id:"_3、io复用模型-i-o-multiplexing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、io复用模型-i-o-multiplexing"}},[t._v("#")]),t._v(" 3、IO复用模型(I/O multiplexing)")]),t._v(" "),a("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/framework/netty/nettyio-3.png"),alt:"wxmp"}}),t._v(" "),a("p",[t._v("进程调用select,如果没有套接字变为可读，则阻塞，直到有可读套接字之后，调用recvfrom函数，返回结果。")]),t._v(" "),a("h4",{attrs:{id:"_4、信号驱动式io模型-signal-driven-i-o"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、信号驱动式io模型-signal-driven-i-o"}},[t._v("#")]),t._v(" 4、信号驱动式IO模型(signal-driven I/O)")]),t._v(" "),a("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/framework/netty/nettyio-4.png"),alt:"wxmp"}}),t._v(" "),a("p",[t._v("进程先注册信号驱动，之后进程不阻塞，当数据准备好后，会给进程返回信号提示，这时进程调用ecvfrom函数，返回数据。")]),t._v(" "),a("h4",{attrs:{id:"_5、异步io模型-asynchronous-i-o"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、异步io模型-asynchronous-i-o"}},[t._v("#")]),t._v(" 5、异步IO模型(asynchronous I/O)")]),t._v(" "),a("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/framework/netty/nettyio-5.png"),alt:"wxmp"}}),t._v(" "),a("p",[t._v("由POSIX规范定义，应用程序告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到应用程序的缓冲区）完成后通知应用程序。这种模型与信号驱动模型的主要区别在于：信号驱动I/O是由内核通知应用程序何时启动一个I/O操作，而异步I/O模型是由内核通知应用程序I/O操作何时完成。")]),t._v(" "),a("h3",{attrs:{id:"io模型对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#io模型对比"}},[t._v("#")]),t._v(" IO模型对比")]),t._v(" "),a("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/framework/netty/nettyio-6.png"),alt:"wxmp"}}),t._v(" "),a("p",[t._v("阻塞越少，理论上性能也越优。")]),t._v(" "),a("ul",[a("li",[t._v("阻塞式IO，每个连接要对应一个线程单独处理，浪费资源。")]),t._v(" "),a("li",[t._v("非阻塞式IO，需要不断的轮询，也耗费CPU资源。")]),t._v(" "),a("li",[t._v("信号驱动式IO,在大量IO操作时会有信号队列溢出，且对于TCP而言，通知条件过多，每一个进行判断会消耗资源。")]),t._v(" "),a("li",[t._v("异步IO,理论最优，但是目前Linux支持还不是很完善。")])]),t._v(" "),a("p",[t._v("因此在Linux下网络编程都以IO复用模型为主。")]),t._v(" "),a("h2",{attrs:{id:"参考文章"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章")]),t._v(" "),a("ul",[a("li",[t._v("https://www.yht7.com/news/7975")])])])}),[],!1,null,null,null);s.default=r.exports}}]);