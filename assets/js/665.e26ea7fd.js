(window.webpackJsonp=window.webpackJsonp||[]).push([[665],{1181:function(s,t,e){"use strict";e.r(t);var a=e(53),_=Object(a.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),e("p",[s._v("本文主要是介绍 JMS规范-精华总结 。")])]),s._v(" "),e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#一、简介"}},[s._v("一、简介")])]),e("li",[e("a",{attrs:{href:"#二、常用术语介绍"}},[s._v("二、常用术语介绍")])]),e("li",[e("a",{attrs:{href:"#三、jms基本概念及原理详解"}},[s._v("三、JMS基本概念及原理详解")]),e("ul",[e("li",[e("a",{attrs:{href:"#_1、基本概念"}},[s._v("1、基本概念")])]),e("li",[e("a",{attrs:{href:"#_2、体系架构"}},[s._v("2、体系架构")])]),e("li",[e("a",{attrs:{href:"#_3、jms消息模型-即点对点和发布订阅模型"}},[s._v("3、JMS消息模型(即点对点和发布订阅模型)")])]),e("li",[e("a",{attrs:{href:"#_4、p2p"}},[s._v("4、P2P")])]),e("li",[e("a",{attrs:{href:"#_5、pub-sub-发布-订阅模式"}},[s._v("5、Pub/Sub（发布/订阅模式）")])]),e("li",[e("a",{attrs:{href:"#_6、关于消息的消费"}},[s._v("6、关于消息的消费")])])])]),e("li",[e("a",{attrs:{href:"#jms应用程序接口"}},[s._v("JMS应用程序接口")]),e("ul",[e("li",[e("a",{attrs:{href:"#_1、connectionfactory-接口-连接工厂"}},[s._v("1、ConnectionFactory 接口(连接工厂)")])]),e("li",[e("a",{attrs:{href:"#_2、destination-接口-目标"}},[s._v("2、Destination 接口(目标)")])]),e("li",[e("a",{attrs:{href:"#_3、connection-接口-连接"}},[s._v("3、Connection 接口(连接)")])]),e("li",[e("a",{attrs:{href:"#_4、session-接口-会话"}},[s._v("4、Session 接口(会话)")])]),e("li",[e("a",{attrs:{href:"#_5、messageproducer-接口-消息的生产者"}},[s._v("5、MessageProducer 接口(消息的生产者)")])]),e("li",[e("a",{attrs:{href:"#_6、messageconsumer-接口-消息消费者"}},[s._v("6、MessageConsumer 接口(消息消费者)")])]),e("li",[e("a",{attrs:{href:"#_7、message-接口-消息"}},[s._v("7、Message 接口（消息）")])]),e("li",[e("a",{attrs:{href:"#_8、messagelistener"}},[s._v("8、MessageListener")])])])]),e("li",[e("a",{attrs:{href:"#四、jms提供者实现"}},[s._v("四、JMS提供者实现")])]),e("li",[e("a",{attrs:{href:"#参考文章"}},[s._v("参考文章")])])])]),e("p"),s._v(" "),e("p",[s._v("JAVA消息服务JMS规范及原理详解")]),s._v(" "),e("h2",{attrs:{id:"一、简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、简介"}},[s._v("#")]),s._v(" 一、简介")]),s._v(" "),e("p",[s._v("JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。")]),s._v(" "),e("p",[s._v("JMS允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。")]),s._v(" "),e("h2",{attrs:{id:"二、常用术语介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、常用术语介绍"}},[s._v("#")]),s._v(" 二、常用术语介绍")]),s._v(" "),e("p",[s._v("在提到JMS时，我们通常会说到一些术语，解释如下：")]),s._v(" "),e("ul",[e("li",[e("ol",[e("li",[s._v("消息中间件（JMS Provider) ： 指提供了对JMS协议的第三方组件，比如ActiveMQ就是一个消息中间件，另外比较知名的还有KFA, Rabbit MQ等。")])])]),s._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[s._v("消息模式：分为点对点（Point to Point，即P2P）和发布/订阅（Pub/Sub)，对应的数据结构分别是队列（Queue)和主题（Topic)")])])]),s._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[s._v("消息（Message): 通信内容的载体，其结构主要分为消息头，属性和消息体，并且根据存储结构的不同分为好几种，后面会详细提到。")])])]),s._v(" "),e("li",[e("ol",{attrs:{start:"4"}},[e("li",[s._v("消息生产者：产生消息的一方，在P2P模式下，指消息发送者(Sender)，在P/S模式下指消息发布者(Publisher)")])])]),s._v(" "),e("li",[e("ol",{attrs:{start:"5"}},[e("li",[s._v("消息消费者：接收消息的一方，对应于两种模式分别是消息接收者（Receiver）和消息订阅者(Subscriber)")])])])]),s._v(" "),e("h2",{attrs:{id:"三、jms基本概念及原理详解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、jms基本概念及原理详解"}},[s._v("#")]),s._v(" 三、JMS基本概念及原理详解")]),s._v(" "),e("h3",{attrs:{id:"_1、基本概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、基本概念"}},[s._v("#")]),s._v(" 1、基本概念")]),s._v(" "),e("p",[s._v("JMS是java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。")]),s._v(" "),e("h3",{attrs:{id:"_2、体系架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、体系架构"}},[s._v("#")]),s._v(" 2、体系架构")]),s._v(" "),e("p",[s._v("JMS由以下元素组成。")]),s._v(" "),e("p",[s._v("1.JMS提供者\n　　连接面向消息中间件的，JMS接口的一个实现。提供者可以是Java平台的JMS实现，也可以是非Java平台的面向消息中间件的适配器。")]),s._v(" "),e("p",[s._v("2.JMS客户\n　　生产或消费消息的基于Java的应用程序或对象。")]),s._v(" "),e("p",[s._v("3.JMS生产者\n　　创建并发送消息的JMS客户。")]),s._v(" "),e("p",[s._v("4.JMS消费者\n　　接收消息的JMS客户。")]),s._v(" "),e("p",[s._v("5.JMS消息\n　　包括可以在JMS客户之间传递的数据的对象")]),s._v(" "),e("p",[s._v("6.JMS队列\n　　一个容纳那些被发送的等待阅读的消息的区域。队列暗示，这些消息将按照顺序发送。一旦一个消息被阅读，该消息将被从队列中移走。")]),s._v(" "),e("p",[s._v("7.JMS主题\n　　一种支持发送消息给多个订阅者的机制。")]),s._v(" "),e("h3",{attrs:{id:"_3、jms消息模型-即点对点和发布订阅模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、jms消息模型-即点对点和发布订阅模型"}},[s._v("#")]),s._v(" 3、JMS消息模型(即点对点和发布订阅模型)")]),s._v(" "),e("p",[s._v("1、Point-to-Point(P2P)")]),s._v(" "),e("p",[s._v("2、Publish/Subscribe(Pub/Sub)")]),s._v(" "),e("h3",{attrs:{id:"_4、p2p"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、p2p"}},[s._v("#")]),s._v(" 4、P2P")]),s._v(" "),e("p",[e("strong",[s._v("1、P2P模式图效果")]),s._v(" "),e("img",{staticClass:"zoom-custom-imgs",attrs:{src:s.$withBase("/assets/img/middleware/jms/sumprin-1.png"),alt:"wxmp"}}),s._v(" "),e("strong",[s._v("2、涉及到的概念")])]),s._v(" "),e("ul",[e("li",[s._v("2.1、消息队列（Queue）")]),s._v(" "),e("li",[s._v("2.2、提供者(Sender)")]),s._v(" "),e("li",[s._v("2.3、消费者(Receiver)")]),s._v(" "),e("li",[s._v("2.4、每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。")])]),s._v(" "),e("p",[e("strong",[s._v("3、P2P的特点")])]),s._v(" "),e("ul",[e("li",[s._v("3.1、每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)")]),s._v(" "),e("li",[s._v("3.2、提供者和消费者之间在时间上没有依赖性，也就是说当提供者发送了消息之后，不管消费者有没有正在运行，它不会影响到消息被发送到队列")]),s._v(" "),e("li",[s._v("3.3、每条消息仅会传送给一个消费者。可能会有多个消费者在一个队列中侦听，但是每个队列中的消息只能被队列中的一个消费者所消费。")]),s._v(" "),e("li",[s._v("3.4、消息存在先后顺序。一个队列会按照消息服务器将消息放入队列中的顺序，把它们传送给消费者。当已被消费时，就会从队列头部将它们删除（除非使用了消息优先级）。")]),s._v(" "),e("li",[s._v("3.5、消费者在成功接收消息之后需向队列应答成功\n　\n　　　PS:如果你希望发送的每个消息都应该被成功处理的话，那么你需要P2P模式。")])]),s._v(" "),e("h3",{attrs:{id:"_5、pub-sub-发布-订阅模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、pub-sub-发布-订阅模式"}},[s._v("#")]),s._v(" 5、Pub/Sub（发布/订阅模式）")]),s._v(" "),e("p",[e("strong",[s._v("1、Pub/Sub模式效果图")])]),s._v(" "),e("img",{staticClass:"zoom-custom-imgs",attrs:{src:s.$withBase("/assets/img/middleware/jms/sumprin-2.png"),alt:"wxmp"}}),s._v(" "),e("p",[e("strong",[s._v("2、涉及到的概念")])]),s._v(" "),e("ul",[e("li",[s._v("2.1、主题（Topic）")]),s._v(" "),e("li",[s._v("2.2、发布者（Publisher）")]),s._v(" "),e("li",[s._v("2.3、订阅者（Subscriber）")])]),s._v(" "),e("p",[s._v("PS:客户端将消息发送到主题。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。\n　　\n"),e("strong",[s._v("3、Pub/Sub（发布/订阅模式）的特点")])]),s._v(" "),e("ul",[e("li",[s._v("3.1、每个消息可以有多个消费者")]),s._v(" "),e("li",[s._v("3.2、发布者和订阅者之间有时间上的依赖性。针对某个主题的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。")]),s._v(" "),e("li",[s._v("3.3、为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。")]),s._v(" "),e("li",[s._v("3.4、每条消息都会传送给称为订阅者的多个消息消费者。订阅者有许多类型，包括持久型、非持久型和动态型。")]),s._v(" "),e("li",[s._v("3.5、发布者通常不会知道、也意识不到哪一个订阅者正在接收主题消息。")]),s._v(" "),e("li",[s._v("3.6、消息被推送给消费者，这意味着消息会传送给消费者，而无须请求。")])]),s._v(" "),e("p",[s._v("PS:如果你希望发送的消息可以不被做任何处理、或者被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型")]),s._v(" "),e("h3",{attrs:{id:"_6、关于消息的消费"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6、关于消息的消费"}},[s._v("#")]),s._v(" 6、关于消息的消费")]),s._v(" "),e("p",[s._v("在JMS中，消息的产生和消息是异步的。对于消费来说，JMS的消息者可以通过两种方式来消费消息。")]),s._v(" "),e("p",[e("strong",[s._v("6.1、同步")])]),s._v(" "),e("p",[s._v("订阅者或消费者调用receive方法来接收消息，receive方法在能够接收到消息之前（或超时之前）将一直阻塞")]),s._v(" "),e("p",[e("strong",[s._v("6.2、异步")])]),s._v(" "),e("p",[s._v("订阅者或消费者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。")]),s._v(" "),e("h2",{attrs:{id:"jms应用程序接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jms应用程序接口"}},[s._v("#")]),s._v(" JMS应用程序接口")]),s._v(" "),e("h3",{attrs:{id:"_1、connectionfactory-接口-连接工厂"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、connectionfactory-接口-连接工厂"}},[s._v("#")]),s._v(" 1、ConnectionFactory 接口(连接工厂)")]),s._v(" "),e("p",[s._v("创建Connection对象的工厂，根据消息类型的不同，用户将使用队列连接工厂，或者主题连接工厂分，")]),s._v(" "),e("p",[s._v("别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。")]),s._v(" "),e("h3",{attrs:{id:"_2、destination-接口-目标"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、destination-接口-目标"}},[s._v("#")]),s._v(" 2、Destination 接口(目标)")]),s._v(" "),e("p",[s._v("Destination是一个包装了消息目标标识符的被管对象，消息目标是指消息发布和接收的地点，或者是队列，或者是主题。")]),s._v(" "),e("p",[s._v("是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;")]),s._v(" "),e("p",[s._v("对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。")]),s._v(" "),e("p",[s._v("所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。")]),s._v(" "),e("h3",{attrs:{id:"_3、connection-接口-连接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、connection-接口-连接"}},[s._v("#")]),s._v(" 3、Connection 接口(连接)")]),s._v(" "),e("p",[s._v("Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。\nConnection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。")]),s._v(" "),e("h3",{attrs:{id:"_4、session-接口-会话"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、session-接口-会话"}},[s._v("#")]),s._v(" 4、Session 接口(会话)")]),s._v(" "),e("p",[s._v("Session是我们操作消息的接口。表示一个单线程的上下文，用于发送和接收消息。")]),s._v(" "),e("p",[s._v("由于会话是单线程的，所以消息是连续的，就是说消息是按照发送的顺序一个一个接收的。")]),s._v(" "),e("p",[s._v("可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当我们需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。")]),s._v(" "),e("p",[s._v("同样，也分QueueSession和TopicSession。")]),s._v(" "),e("h3",{attrs:{id:"_5、messageproducer-接口-消息的生产者"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、messageproducer-接口-消息的生产者"}},[s._v("#")]),s._v(" 5、MessageProducer 接口(消息的生产者)")]),s._v(" "),e("p",[s._v("消息生产者由Session创建，并用于将消息发送到Destination。消费者可以同步地（阻塞模式），或异步（非阻塞）接收队列和主题类型的消息。")]),s._v(" "),e("p",[s._v("同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。")]),s._v(" "),e("h3",{attrs:{id:"_6、messageconsumer-接口-消息消费者"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6、messageconsumer-接口-消息消费者"}},[s._v("#")]),s._v(" 6、MessageConsumer 接口(消息消费者)")]),s._v(" "),e("p",[s._v("消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。")]),s._v(" "),e("p",[s._v("可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。")]),s._v(" "),e("p",[s._v("当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。")]),s._v(" "),e("h3",{attrs:{id:"_7、message-接口-消息"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7、message-接口-消息"}},[s._v("#")]),s._v(" 7、Message 接口（消息）")]),s._v(" "),e("p",[s._v("是在消费者和生产者之间传送的对象，也就是说从一个应用程序创送到另一个应用程序。一个消息有三个主要部分：")]),s._v(" "),e("ul",[e("li",[s._v("1、消息头（必须）：包含用于识别和为消息寻找路由的操作设置。")]),s._v(" "),e("li",[s._v("2、一组消息属性（可选）：包含额外的属性，支持其他提供者和用户的兼容。可以创建定制的字段和过滤器（消息选择器）。")]),s._v(" "),e("li",[s._v("3、一个消息体（可选）：允许用户创建五种类型的消息（文本消息，映射消息，字节消息，流消息和对象消息）。消息接口非常灵活，并提供了许多方式来定制消息的内容。")])]),s._v(" "),e("p",[s._v("消息接口非常灵活，并提供了许多方式来定制消息的内容。")]),s._v(" "),e("h3",{attrs:{id:"_8、messagelistener"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8、messagelistener"}},[s._v("#")]),s._v(" 8、MessageListener")]),s._v(" "),e("p",[s._v("消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。")]),s._v(" "),e("p",[s._v("EJB中的MDB（Message-Driven Bean）就是一种MessageListener。")]),s._v(" "),e("h2",{attrs:{id:"四、jms提供者实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、jms提供者实现"}},[s._v("#")]),s._v(" 四、JMS提供者实现")]),s._v(" "),e("p",[s._v("要使用Java消息服务，你必须要有一个JMS提供者，管理会话和队列。现在既有开源的提供者也有专有的提供者。\n　　\n开源的提供者包括：Apache ActiveMQ、Kafka、WebMethods、阿里的RocketMQ等")]),s._v(" "),e("h2",{attrs:{id:"参考文章"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[s._v("#")]),s._v(" 参考文章")]),s._v(" "),e("ul",[e("li",[s._v("https://www.cnblogs.com/molao-doing/articles/6557305.html")])])])}),[],!1,null,null,null);t.default=_.exports}}]);