(window.webpackJsonp=window.webpackJsonp||[]).push([[699],{1215:function(t,s,a){"use strict";a.r(s);var _=a(53),l=Object(_.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("本文主要是介绍 主动复制-延迟基础检查 。")])]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#mysql-主从同步延迟的原因及解决办法"}},[t._v("MySQL 主从同步延迟的原因及解决办法")]),a("ul",[a("li",[a("a",{attrs:{href:"#_1-主从同步的延迟的原因"}},[t._v("1. 主从同步的延迟的原因")])]),a("li",[a("a",{attrs:{href:"#_2-主从同步延迟的解决办法"}},[t._v("2. 主从同步延迟的解决办法")])]),a("li",[a("a",{attrs:{href:"#_3-判断主从延迟的方法"}},[t._v("3. 判断主从延迟的方法")])])])]),a("li",[a("a",{attrs:{href:"#参考文章"}},[t._v("参考文章")])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"mysql-主从同步延迟的原因及解决办法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql-主从同步延迟的原因及解决办法"}},[t._v("#")]),t._v(" MySQL 主从同步延迟的原因及解决办法")]),t._v(" "),a("p",[t._v("mysql 用主从同步的方法进行读写分离，减轻主服务器的压力的做法现在在业内做的非常普遍。 主从同步基本上能做到实时同步。我从别的网站借用了主从同步的原理图。")]),t._v(" "),a("img",{staticClass:"zoom-custom-imgs",attrs:{src:t.$withBase("/assets/img/mysqlop/replication/delaybasic-1.png"),alt:"wxmp"}}),t._v(" "),a("p",[t._v("在配置好了， 主从同步以后， 主服务器会把更新语句写入binlog, 从服务器的IO 线程(这里要注意， 5.6.3 之前的IO线程仅有一个，5.6.3之后的有多线程去读了，速度自然也就加快了)回去读取主服务器的binlog 并且写到从服务器的Relay log 里面，然后从服务器的 的SQL thread 会一个一个执行 relay log 里面的sql ， 进行数据恢复。")]),t._v(" "),a("p",[t._v("relay 就是 传递, relay race 就是接力赛的意思")]),t._v(" "),a("h3",{attrs:{id:"_1-主从同步的延迟的原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-主从同步的延迟的原因"}},[t._v("#")]),t._v(" 1. 主从同步的延迟的原因")]),t._v(" "),a("p",[t._v("我们知道， 一个服务器开放Ｎ个链接给客户端来连接的，　这样有会有大并发的更新操作, 但是从服务器的里面读取binlog 的线程仅有一个， 当某个SQL在从服务器上执行的时间稍长 或者由于某个SQL要进行锁表就会导致，主服务器的SQL大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。")]),t._v(" "),a("h3",{attrs:{id:"_2-主从同步延迟的解决办法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-主从同步延迟的解决办法"}},[t._v("#")]),t._v(" 2. 主从同步延迟的解决办法")]),t._v(" "),a("p",[t._v("实际上主从同步延迟根本没有什么一招制敌的办法， 因为所有的SQL必须都要在从服务器里面执行一遍，但是主服务器如果不断的有更新操作源源不断的写入， 那么一旦有延迟产生， 那么延迟加重的可能性就会原来越大。 当然我们可以做一些缓解的措施。")]),t._v(" "),a("p",[t._v("a. 我们知道因为主服务器要负责更新操作， 他对安全性的要求比从服务器高， 所有有些设置可以修改，比如sync_binlog=1，innodb_flush_log_at_trx_commit = 1 之类的设置，而slave则不需要这么高的数据安全，完全可以讲sync_binlog设置为0或者关闭binlog，innodb_flushlog，innodb_flush_log_at_trx_commit 也 可以设置为0来提高sql的执行效率 这个能很大程度上提高效率。另外就是使用比主库更好的硬件设备作为slave。")]),t._v(" "),a("p",[t._v("b. 就是把，一台从服务器当度作为备份使用， 而不提供查询， 那边他的负载下来了， 执行relay log 里面的SQL效率自然就高了。")]),t._v(" "),a("p",[t._v("c. 增加从服务器喽，这个目的还是分散读的压力， 从而降低服务器负载。")]),t._v(" "),a("h3",{attrs:{id:"_3-判断主从延迟的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-判断主从延迟的方法"}},[t._v("#")]),t._v(" 3. 判断主从延迟的方法")]),t._v(" "),a("p",[t._v("MySQL提供了从服务器状态命令，可以通过 show slave status 进行查看， 比如可以看看Seconds_Behind_Master参数的值来判断，是否有发生主从延时。")]),t._v(" "),a("p",[t._v("其值有这么几种：")]),t._v(" "),a("ul",[a("li",[t._v("NULL - 表示io_thread或是sql_thread有任何一个发生故障，也就是该线程的Running状态是No,而非Yes.")]),t._v(" "),a("li",[t._v("0 - 该值为零，是我们极为渴望看到的情况，表示主从复制状态正常")])]),t._v(" "),a("h2",{attrs:{id:"参考文章"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章")]),t._v(" "),a("ul",[a("li",[t._v("https://www.cnblogs.com/xuxubaobao/p/10845656.html")])])])}),[],!1,null,null,null);s.default=l.exports}}]);