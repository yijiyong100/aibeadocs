---
title: 八种常用算法思想
---

::: tip
本文主要是介绍 八种常用算法思想 。
:::

[[toc]]

## 算法工程师必须要知道的8种常用算法思想


### 1.1　枚举算法思想


枚举算法思想的最大特点是，在面对任何问题时它会去尝试每一种解决方法。在进行归纳推理时，如果逐个考察了某类事件的所有可能情况，因而得出一般结论，那么这个结论是可靠的，这种归纳方法叫作枚举法。

**1.1.1　枚举算法基础**

枚举算法的思想是：将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，丢弃不合适的。在C语言中，枚举算法一般使用while循环实现。使用枚举算法解题的基本思路如下。

① 确定枚举对象、枚举范围和判定条件。

② 逐一列举可能的解，验证每个解是否是问题的解。

枚举算法一般按照如下3个步骤进行。

① 题解的可能范围，不能遗漏任何一个真正解，也要避免有重复。

② 判断是否是真正解的方法。

③ 使可能解的范围降至最小，以便提高解决问题的效率。

枚举算法的主要流程如图1-1所示。


<img class= "zoom-custom-imgs" :src="$withBase('/assets/img/algorithm/thought/8comm-1.png')" alt="wxmp">

1-1枚举算法流程图

### 1.2　递推算法思想


与枚举算法思想相比，递推算法能够通过已知的某个条件，利用特定的关系得出中间推论，然后逐步递推，直到得到结果为止。由此可见，递推算法要比枚举算法聪明，它不会尝试每种可能的方案。

**1.2.1　递推算法基础**

递推算法可以不断利用已有的信息推导出新的东西，在日常应用中有如下两种递推 算法。

① 顺推法：从已知条件出发，逐步推算出要解决问题的方法。例如斐波那契数列就可以通过顺推法不断递推算出新的数据。

② 逆推法：从已知的结果出发，用迭代表达式逐步推算出问题开始的条件，即顺推法的逆过程。

### 1.3　递归算法思想


因为递归算法思想往往用函数的形式来体现，所以递归算法需要预先编写功能函数。这些函数是独立的功能，能够实现解决某个问题的具体功能，当需要时直接调用这个函数即可。在本节的内容中，将详细讲解递归算法思想的基本知识。

# 1.3.1　递归算法基础

在计算机编程应用中，递归算法对解决大多数问题是十分有效的，它能够使算法的描述变得简洁而且易于理解。递归算法有如下3个特点。

① 递归过程一般通过函数或子过程来实现。

② 递归算法在函数或子过程的内部，直接或者间接地调用自己的算法。

③ 递归算法实际上是把问题转化为规模缩小了的同类问题的子问题，然后再递归调用函数或过程来表示问题的解。

在使用递归算法时，读者应该注意如下4点。

① 递归是在过程或函数中调用自身的过程。

② 在使用递归策略时，必须有一个明确的递归结束条件，这称为递归出口。

③ 递归算法通常显得很简洁，但是运行效率较低，所以一般不提倡用递归算法设计程序。

④ 在递归调用过程中，系统用栈来存储每一层的返回点和局部量。如果递归次数过多，则容易造成栈溢出，所以一般不提倡用递归算法设计程序。

### 1.4　分治算法思想

在本节将要讲解的分治算法也采取了各个击破的方法，将一个规模为*N*的问题分解为*K*个规模较小的子问题，这些子问题相互独立且与原问题性质相同。只要求出子问题的解，就可得到原问题的解。

**1.4.1　分治算法基础**

在编程过程中，经常遇到处理数据相当多、求解过程比较复杂、直接求解法会比较耗时的问题。在求解这类问题时，可以采用各个击破的方法。具体做法是：先把这个问题分解成几个较小的子问题，找到求出这几个子问题的解法后，再找到合适的方法，把它们组合成求整个大问题的解。如果这些子问题还是比较大，还可以继续再把它们分成几个更小的子问题，以此类推，直至可以直接求出解为止。这就是分治算法的基本思想。

使用分治算法解题的一般步骤如下。

① 分解，将要解决的问题划分成若干个规模较小的同类问题。

② 求解，当子问题划分得足够小时，用较简单的方法解决。

③ 合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。

### 1.5　贪心算法思想

本节所要讲解的贪心算法也被称为贪婪算法，它在求解问题时总想用在当前看来是最好方法来实现。这种算法思想不从整体最优上考虑问题，仅仅是在某种意义上的局部最优求解。虽然贪心算法并不能得到所有问题的整体最优解，但是面对范围相当广泛的许多问题时，能产生整体最优解或者是整体最优解的近似解。由此可见，贪心算法只是追求某个范围内的最优，可以称之为“温柔的贪婪”。

**1.5.1　贪心算法基础**

贪心算法从问题的某一个初始解出发，逐步逼近给定的目标，以便尽快求出更好的解。当达到算法中的某一步不能再继续前进时，就停止算法，给出一个近似解。由贪心算法的特点和思路可看出，贪心算法存在以下3个问题。

① 不能保证最后的解是最优的。

② 不能用来求最大或最小解问题。

③ 只能求满足某些约束条件的可行解的范围。

贪心算法的基本思路如下。

① 建立数学模型来描述问题。

② 把求解的问题分成若干个子问题。

③ 对每一子问题求解，得到子问题的局部最优解。

④ 把子问题的局部最优解合并成原来解问题的一个解。

实现该算法的基本过程如下。

（1）从问题的某一初始解出发。

（2）while能向给定总目标前进一步。

（3）求出可行解的一个解元素。

（4）由所有解元素组合成问题的一个可行解。

### 1.6　试探法算法思想

试探法也叫回溯法，试探法的处事方式比较委婉，它先暂时放弃关于问题规模大小的限制，并将问题的候选解按某种顺序逐一进行枚举和检验。当发现当前候选解不可能是正确的解时，就选择下一个候选解。如果当前候选解除了不满足问题规模要求外能够满足所有其他要求时，则继续扩大当前候选解的规模，并继续试探。如果当前候选解满足包括问题规模在内的所有要求时，该候选解就是问题的一个解。在试探算法中，放弃当前候选解，并继续寻找下一个候选解的过程称为回溯。扩大当前候选解的规模，并继续试探的过程称为向前试探。

**1.6.1　试探法算法基础**

使用试探算法解题的基本步骤如下所示。

① 针对所给问题，定义问题的解空间。

② 确定易于搜索的解空间结构。

③ 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

试探法为了求得问题的正确解，会先委婉地试探某一种可能的情况。在进行试探的过程中，一旦发现原来选择的假设情况是不正确的，立即会自觉地退回一步重新选择，然后继续向前试探，如此这般反复进行，直至得到解或证明无解时才死心。

假设存在一个可以用试探法求解的问题P，该问题表达为：对于已知的由*n*元组（*y*1，*y*2，…，*yn*）组成的一个状态空间*E*={（*y*1，*y*2，…，*yn*）∣*yi*∈*Si*，*i*=1，2，…，*n*}，给定关于*n*元组中的一个分量的一个约束集*D*，要求*E*中满足*D*的全部约束条件的所有*n*元组。其中，*Si*是分量*yi*的定义域，且|*Si*|有限，*i*=1，2，…，*n*。*E*中满足*D*的全部约束条件的任一*n*元组为问题P的一个解。

解问题P的最简单方法是使用枚举法，即对*E*中的所有*n*元组逐一检测其是否满足*D*的全部约束，如果满足，则为问题P的一个解。但是这种方法的计算量非常大。

对于现实中的许多问题，所给定的约束集*D*具有完备性，即*i*元组（*y*1，*y*2，…，*yi*）满足*D*中仅涉及*y*1，*y*2，…，*yj*的所有约束，这意味着*j*（*j*<*i*）元组（*y*1，*y*2，…，*yj*）一定也满足*D*中仅涉及*y*1，*y*2，…，*yj*的所有约束，*i*=1，2，…，*n*。换句话说，只要存在0<=j<=*n*−1，使得（*y* 1，*y* 2，…，*yj*）违反*D*中仅涉及*y*1，*y*2，…，*yj*的约束之一，则以（*y*1，*y*2，…，*yj*）为前缀的任何*n*元组（*y*1，*y*2，…，*yj*，*yj+*1，…，*yn*）一定也违反*D*中仅涉及*y* 1，*y* 2，…，*yi*的一个约束，*n>=i*>;*j*。因此，对于约束集*D*具有完备性的问题P，一旦检测断定某个*j*元组（*y*1，*y*2，…，*yj*）违反*D*中仅涉及*y*1，*y*2，…，*yj*的一个约束，就可以肯定，以（*y*1，*y*2，…，*yj*）为前缀的任何*n*元组（*y*1，*y*2，…，*yj*，*yj+*1，…，*yn*）都不会是问题P的解，因而就不必去搜索它们、检测它们。试探法是针对这类问题而推出的，比枚举算法的效率更高。

### 1.7　迭代算法

迭代法也称辗转法，是一种不断用变量的旧值递推新值的过程，在解决问题时总是重复利用一种方法。与迭代法相对应的是直接法（或者称为一次解法），即一次性解决问题。迭代法又分为精确迭代和近似迭代。“二分法”和“牛顿迭代法”属于近似迭代法，功能都比较类似。

**1.7.1　迭代算法基础**

迭代算法是用计算机解决问题的一种基本方法。它利用计算机运算速度快、适合做重复性操作的特点，让计算机对一组指令（或一定步骤）进行重复执行，在每次执行这组指令（或这些步骤）时，都从变量的原值推出它的一个新值。

在使用迭代算法解决问题时，需要做好如下3个方面的工作。

（1）确定迭代变量

在可以使用迭代算法解决的问题中，至少存在一个迭代变量，即直接或间接地不断由旧值递推出新值的变量。

（2）建立迭代关系式

迭代关系式是指如何从变量的前一个值推出其下一个值的公式或关系。通常可以使用递推或倒推的方法来建立迭代关系式，迭代关系式的建立是解决迭代问题的关键。

（3）对迭代过程进行控制

在编写迭代程序时，必须确定在什么时候结束迭代过程，不能让迭代过程无休止地重复执行下去。通常可分为如下两种情况来控制迭代过程：

① 所需的迭代次数是个确定的值，可以计算出来，可以构建一个固定次数的循环来实现对迭代过程的控制；

② 所需的迭代次数无法确定，需要进一步分析出用来结束迭代过程的条件。

### 1.8　模拟算法思想

模拟是对真实事物或者过程的虚拟。在编程时为了实现某个功能，可以用语言来模拟那个功能，模拟成功也就相应地表示编程成功。

1.8.1　模拟算法的思路

模拟算法是一种基本的算法思想，可用于考查程序员的基本编程能力，其解决方法就是根据题目给出的规则对题目要求的相关过程进行编程模拟。在解决模拟类问题时，需要注意字符串处理、特殊情况处理和对题目意思的理解。在C语言中，通常使用函数srand()和rand()来生成随机数。其中，函数srand()用于初始化随机数发生器，然后使用函数rand()来生成随机数。如果要使用上述两个函数，则需要在源程序头部包含time.h文件。在程序设计过程中，可使用随机函数来模拟自然界中发生的不可预测情况。在解题时，需要仔细分析题目给出的规则，要尽可能地做到全面考虑所有可能出现的情况，这是解模拟类问题的关键点之一。

## 参考文章
* https://www.toutiao.com/a6653981171921191432/