---
title: 并发编程-JUC博客推荐
---


::: tip
本文主要是介绍 并发编程-【JUC精彩博客推荐】 。
:::

[[toc]]


## 【博客专栏推荐（一）】

### 专栏地址

**[https://segmentfault.com/u/ressmix](https://segmentfault.com/u/ressmix###)**



### 推荐文章

[Java多线程基础（二）——Java内存模型](https://segmentfault.com/a/1190000015555973)

[透彻理解Java并发编程系列](https://segmentfault.com/a/1190000015558984)

[Java多线程基础（一）——线程与锁](https://segmentfault.com/a/1190000015555859)



## 【博客专栏推荐（二）】



### 专栏地址

[java-多线程-JUC线程池(7)](https://www.cnblogs.com/bjlhx/category/1485200.html)

[java-多线程-基础(15)](https://www.cnblogs.com/bjlhx/category/1485198.html)

[java-多线程-集合(12)](https://www.cnblogs.com/bjlhx/category/1485631.html)

[java-多线程-锁(9)](https://www.cnblogs.com/bjlhx/category/1086008.html)



### 推荐文章

[001-多线程-JUC线程池-线程池架构-Executor、ExecutorService、ThreadPoolExecutor、Executors](https://www.cnblogs.com/bjlhx/p/11052875.html)

[001-多线程-JUC集合-框架概述](https://www.cnblogs.com/bjlhx/p/11067891.html)

[001-多线程-基础-进程线程、线程状态、优先级、用户线程和守护线程](https://www.cnblogs.com/bjlhx/p/7588128.html)

[001-多线程-锁-架构【同步锁、JUC锁】](https://www.cnblogs.com/bjlhx/p/11053421.html)





## 【博客专栏推荐（三）】

### 专栏地址

[https://www.cnblogs.com/AliCoder/category/1598003.html](https://www.cnblogs.com/AliCoder/category/1598003.html
)



### 推荐文章

[Java并发指南14：JUC中常用的Unsafe和Locksupport](https://www.cnblogs.com/AliCoder/p/11838532.html)

[Java并发指南11：解读 Java 阻塞队列 BlockingQueue](https://www.cnblogs.com/AliCoder/p/11831669.html)

[Java并发指南10：Java 读写锁 ReentrantReadWriteLock 源码分析](https://www.cnblogs.com/AliCoder/p/11831650.html)

[Java并发指南8：AQS中的公平锁与非公平锁，Condtion](https://www.cnblogs.com/AliCoder/p/11831637.html)

[Java并发指南7：JUC的核心类AQS详解](https://www.cnblogs.com/AliCoder/p/11831455.html)

[Java并发指南6：Java内存模型JMM总结](https://www.cnblogs.com/AliCoder/p/11822880.html)

[Java并发指南5：JMM中的final关键字解析](https://www.cnblogs.com/AliCoder/p/11822795.html)

[Java并发指南4：Java中的锁 Lock和synchronized](https://www.cnblogs.com/AliCoder/p/11822783.html)

[Java并发指南3：并发三大问题与volatile关键字，CAS操作](https://www.cnblogs.com/AliCoder/p/11822769.html)

[Java并发指南2：深入理解Java内存模型JMM](https://www.cnblogs.com/AliCoder/p/11822730.html)

[Java并发指南1：并发基础与Java多线程](https://www.cnblogs.com/AliCoder/p/11822713.html)





## 【博客专栏推荐（四）】

### 专栏地址

[https://www.cnblogs.com/mtcarpenter/category/1851392.html](https://www.cnblogs.com/mtcarpenter/category/1851392.html)



### 推荐文章

[突击并发编程JUC系列-万字长文解密 JUC 面试题](https://www.cnblogs.com/mtcarpenter/p/13876808.html)

[突击并发编程JUC系列-阻塞队列 BlockingQueue](https://www.cnblogs.com/mtcarpenter/p/13862372.html)

[突击并发编程JUC系列-并发容器ConcurrentHashMap](https://www.cnblogs.com/mtcarpenter/p/13824792.html)

[突击并发编程JUC系列-Locksupport 与 Condition](https://www.cnblogs.com/mtcarpenter/p/13818729.html)

[突击并发编程JUC系列-ReentrantReadWriteLock](https://www.cnblogs.com/mtcarpenter/p/13806870.html)

[突击并发编程JUC系列-ReentrantLock](https://www.cnblogs.com/mtcarpenter/p/13790107.html)

[突击并发编程JUC系列-并发工具 Semaphore](https://www.cnblogs.com/mtcarpenter/p/13752960.html)

[突击并发编程JUC系列-并发工具 CyclicBarrier](https://www.cnblogs.com/mtcarpenter/p/13748180.html)

[突击并发编程JUC系列-并发工具 CountDownLatch](https://www.cnblogs.com/mtcarpenter/p/13743202.html)

[突击并发编程JUC系列-JDK1.8 扩展类型 LongAdder](https://www.cnblogs.com/mtcarpenter/p/13739318.html)

[突击并发编程JUC系列-原子更新字段类AtomicStampedReference](https://www.cnblogs.com/mtcarpenter/p/13728330.html)

[突击并发编程JUC系列-原子引用AtomicReference](https://www.cnblogs.com/mtcarpenter/p/13723524.html)

[突击并发编程JUC系列-数组类型AtomicLongArray](https://www.cnblogs.com/mtcarpenter/p/13720964.html)

[突击并发编程JUC系列-原子更新AtomicLong](https://www.cnblogs.com/mtcarpenter/p/13710398.html)

[突击并发编程JUC系列-启航篇](https://www.cnblogs.com/mtcarpenter/p/13705055.html)





## 【博客专栏推荐（五）】

### 专栏地址

[https://www.cnblogs.com/mtcarpenter/category/1851392.html](https://www.cnblogs.com/mtcarpenter/category/1851392.html)



### 推荐文章

[JUC——线程池](https://www.cnblogs.com/itermis/p/9139054.html)

摘要：线程池本质的概念就是一堆线程一起完成一件事情。 Executor ExecutorService ScheduledExecutorService Executors 线程池分类 创建线程池使用类：java.util.concurrent.Executors 创建无大小限制的线程池 public s [阅读全文](https://www.cnblogs.com/itermis/p/9139054.html)

[JUC——延迟队列](https://www.cnblogs.com/itermis/p/9133541.html)

摘要：所谓的延迟队列最大的特征是它可以自动通过队列进行脱离，例如：现在有一些对象被临时保存着，但是有可能该集合对象是一个公共对象，那么里面的某些数据如果不在使用的时候就希望其可以在指定的时间达到后自动的消失。 DelayQueue是延迟队列主要的使用类，所谓的延迟队列其实就是=BlockingQueue+ [阅读全文](https://www.cnblogs.com/itermis/p/9133541.html)

[JUC——阻塞队列](https://www.cnblogs.com/itermis/p/9067354.html)

摘要：Queue是一个队列，而队列的主要特征是FIFO先进先出，要实现生产者与消费者模型，也可以采用队列来进行中间的缓冲读取，好处是：生产者可以一直不停歇的生产数据。 BlockingQueue是Queue的子类，它实现有队列的基本特征： 在最初利用Queue实现生产者与消费者模型的时候发现一个问题：所有 [阅读全文](https://www.cnblogs.com/itermis/p/9067354.html)

[JUC——并发集合类](https://www.cnblogs.com/itermis/p/9066144.html)

摘要：如果要进行多个数据的保存，无疑首选类集（List、Set、Queue、Map），在类集的学习的时候也知道一个概念：许多集合的子类都具有同步与异步的差别，但是如果真的要在多线程之中去使用这些类，是否真的可以用呢？ 范例：观察一下类集的问题： 不过很遗憾的是这个时候以上的代码出现了“java.util. [阅读全文](https://www.cnblogs.com/itermis/p/9066144.html)

[JUC——线程同步辅助工具类（Exchanger，CompletableFuture）](https://www.cnblogs.com/itermis/p/9025148.html)

摘要：Exchanger交换空间 如果现在有两个线程，一个线程负责生产数据，另外一个线程负责消费数据，那么这个两个线程之间一定会存在一个公共的区域，那么这个区域的实现在JUC包之中称为Exchanger。 java.util.concurrent.Exchanger类表示一种两个线程可以进行互相交换对象的 [阅读全文](https://www.cnblogs.com/itermis/p/9025148.html)

[JUC——线程同步辅助工具类（Semaphore，CountDownLatch，CyclicBarrier）](https://www.cnblogs.com/itermis/p/9004041.html)

摘要：锁的机制从整体的运行转态来讲核心就是：阻塞，解除阻塞，但是如果仅仅是这点功能，那么JUC并不能称为一个优秀的线程开发框架，然而是因为在juc里面提供了大量方便的同步工具辅助类。 Semaphore信号量 Semaphore通常用于限制可以访问某些资源（物理or逻辑）的线程数目。 例如，大家排队去银行 [阅读全文](https://www.cnblogs.com/itermis/p/9004041.html)

[JUC——线程同步锁（LockSupport阻塞原语）](https://www.cnblogs.com/itermis/p/8992009.html)

摘要：java.util.concurrent.locks.LockSupport这个是一个独立的类，这个类的主要功能是用来解决Thread里面提供的suspend()（挂起线程）、resume()（恢复运行）方法，这个两个方法的本质上会存在有死锁的嫌疑，所以从JDK1.4开始将其就已经列为不建议使用的方 [阅读全文](https://www.cnblogs.com/itermis/p/8992009.html)

[JUC——线程同步锁（Condition精准控制）](https://www.cnblogs.com/itermis/p/8986899.html)

摘要：在进行锁处理的时候还有一个接口：Condition，这个接口可以由用户来自己进行锁的对象创建。 Condition的作用是对锁进行更精确的控制。 Condition的await()方法相当于Object的wait()方法，Condition的signal()方法相当于Object的notify()方 [阅读全文](https://www.cnblogs.com/itermis/p/8986899.html)

[JUC——线程同步锁（ReentrantReadWriteLock读写锁）](https://www.cnblogs.com/itermis/p/8962216.html)

摘要：读写锁简介 所谓的读写锁值得是两把锁，在进行数据写入的时候有一个把“写锁”，而在进行数据读取的时候有一把“读锁”。 写锁会实现线程安全同步处理操作，而读锁可以被多个对象读取获取。 读写锁：ReadWriteLock 读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由JVM自己控制的。 R [阅读全文](https://www.cnblogs.com/itermis/p/8962216.html)

[JUC——线程同步锁（ReentrantLock）](https://www.cnblogs.com/itermis/p/8961003.html)

摘要：ReentrantLock简介 ReentrantLock是一个可重复的互斥锁，又被称为独占锁，可重入的意思是：ReentrantLock锁可以被单个线程多次获取。但是在同一个时间点只能被一个线程锁持有 ReentrantLock使用一个FIFO（先进先出）的等待队里来管理获取该锁所有线程的。 Re [阅读全文](https://www.cnblogs.com/itermis/p/8961003.html)

[JUC——线程同步锁（锁处理机制简介）](https://www.cnblogs.com/itermis/p/8950228.html)

摘要：锁处理机制简介 juc的开发框架解决的核心问题是并发访问和数据安全操作问题，当进行并发访问的时候如果对于锁的控制不当，就会造成死锁这样的阻塞问题。 为了解决这样的缺陷，juc里面重新针对于锁的概念进行了设计。 JUC锁机制 JUC锁机制包括以下几个组成部分： 核心接口：Lock，ReadWriteL [阅读全文](https://www.cnblogs.com/itermis/p/8950228.html)

[JUC——ThreadFactory线程工厂类（四）](https://www.cnblogs.com/itermis/p/8939883.html)

摘要：ThreadFactory线程工厂类 在默认情况下如果要想创建一个线程类对象，大部分情况的选择是：直接通过子类为父类进行实例化，利用Runnable子类为Runnable接口实例化。 或者直接调用Lambda表达式来进行处理，不过在多线程运行机制里面考虑到线程对象创建的合理性，juc专门提供了一个T [阅读全文](https://www.cnblogs.com/itermis/p/8939883.html)

[JUC——原子类操作（三）](https://www.cnblogs.com/itermis/p/8931665.html)

摘要：原子类操作 既然强调了并发访问，那么就必须考虑操作系统位数：32位操作系统还是64位操作系统，对于long型数据类型而言，是64位的。但是如果现在项目运行在32位系统上，则long型数据会占用32位空间进行数据的保存。 如果现在每一个程序类里面都去使用long类型，那么进行处理的时候都需要手动进行v [阅读全文](https://www.cnblogs.com/itermis/p/8931665.html)

[JUC——TimeUnit工具类（二）](https://www.cnblogs.com/itermis/p/8929765.html)

摘要：TimeUnit工具类 在java.util.concurrent开发包里面提供有一个TimeUnit类，这个类单独看它的描述是一个时间单元类。该类是一个枚举类，这也是juc开包里面唯一的一个枚举类。 这个类之中支持有：日（DAYS）、时（HOURS）、分（MINUTS）、秒（SECONDS）、毫秒 [阅读全文](https://www.cnblogs.com/itermis/p/8929765.html)

[JUC——JUC开发简介（一）](https://www.cnblogs.com/itermis/p/8927652.html)

摘要：前言 JUC是Java5.0开始提供的一组专门实现多线程并发处理的开发框架，利用JUC开发架构可以有效的解决实际线程项目开发之中出现的死锁、阻塞、资源访问与公平机制。 此笔记主要记录java.util.concurrent开发包之中的各个核心组成类的使用、操作原理分析，并且通过具体的实际代码对多线程 [阅读全文](https://www.cnblogs.com/itermis/p/8927652.html)





## 【博客专栏推荐（六）】

### 专栏地址

[https://www.cnblogs.com/rickiyang/category/1487709.html](https://www.cnblogs.com/rickiyang/category/1487709.html)



### 推荐文章

[java并发编程（二十六）----ThreadLocal的使用](https://www.cnblogs.com/rickiyang/p/11074220.html)

摘要：其实ThreadLocal很多接触过多线程的同学都可能会很陌生，他不像current包里面那些耳熟能详的api一样在我们面前经常出现，更多的他作为一个本地类出现在系统设计里面。...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074220.html)

[java并发编程（二十五）----(JUC集合)LinkedBlockingDeque和ConcurrentLinkedDeque介绍](https://www.cnblogs.com/rickiyang/p/11074245.html)

摘要：Queue除了前面介绍的实现外，还有一种双向的Queue实现Deque。这种队列允许在队列头和尾部进行入队出队操作，因此在功能上比Queue显然要更复杂。LinkedBlock...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074245.html)

[java并发编程（二十四）----(JUC集合)ArrayBlockingQueue和LinkedBlockingQueue介绍](https://www.cnblogs.com/rickiyang/p/11074246.html)

摘要：这一节我们来了解阻塞队列（BlockingQueue），BlockingQueue接口定义了一种阻塞的FIFO queue，每一个BlockingQueue都有一个容量，当容量...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074246.html)

[java并发编程（二十三）----(JUC集合)ConcurrentSkipListMap介绍](https://www.cnblogs.com/rickiyang/p/11074247.html)

摘要：ConcurrentSkipListMap提供了一种线程安全的并发访问的排序映射表。内部是SkipList（跳表）结构实现，在理论上能够在O(log(n))时间内完成查找、插入...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074247.html)

[java并发编程（二十二）----(JUC集合)ConcurrentHashMap介绍](https://www.cnblogs.com/rickiyang/p/11074248.html)

摘要：这一节我们来看一下并发的Map，ConcurrentHashMap和ConcurrentSkipListMap。ConcurrentHashMap通常只被看做并发效率更高的Ma...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074248.html)

[java并发编程（二十一）----(JUC集合)CopyOnWriteArraySet和ConcurrentSkipListSet介绍](https://www.cnblogs.com/rickiyang/p/11074249.html)

摘要：这一节我们来接着介绍JUC集合：CopyOnWriteArraySet和ConcurrentSkipListSet。从名字上来看我们知道CopyOnWriteArraySet与...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074249.html)

[java并发编程（二十）----(JUC集合)CopyOnWriteArrayList介绍](https://www.cnblogs.com/rickiyang/p/11074250.html)

摘要：这一节开始我们正式来介绍JUC集合类。我们按照List、Set、Map、Queue的顺序来进行介绍。这一节我们来看一下CopyOnWriteArrayList。CopyOnWr...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074250.html)

[java并发编程（十九）----(JUC集合)总体框架介绍](https://www.cnblogs.com/rickiyang/p/11074251.html)

摘要：本节我们将继续学习JUC包中的集合类，我们知道jdk中本身自带了一套非线程安全的集合类，我们先温习一下java集合包里面的集合类，然后系统的看一下JUC包里面的集合类到底有什么...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074251.html)

[java并发编程（十八）----(线程池)java线程池框架Fork-Join](https://www.cnblogs.com/rickiyang/p/11074252.html)

摘要：还记得我们在初始介绍线程池的时候提到了Executor框架的体系，到现在为止我们只有一个没有介绍，与ThreadPoolExecutor一样继承与AbstractExecuto...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074252.html)

[java并发编程（十七）----(线程池)java线程池架构和原理](https://www.cnblogs.com/rickiyang/p/11074253.html)

摘要：前面我们简单介绍了线程池的使用，但是对于其如何运行我们还不清楚，Executors为我们提供了简单的线程工厂类，但是我们知道ThreadPoolExecutor是线程池的具体实...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074253.html)

[java并发编程（十六）----(线程池)java线程池的使用](https://www.cnblogs.com/rickiyang/p/11074254.html)

摘要：上节我们简单介绍了线程池，这次我们就来使用一下。Executors提供四种线程池，分别是：newCachedThreadPool，newFixedThreadPool ，new...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074254.html)

[java并发编程（十五）----(线程池)java线程池简介](https://www.cnblogs.com/rickiyang/p/11074255.html)

摘要：好的软件设计不建议手动创建和销毁线程。线程的创建和销毁是非常耗 CPU 和内存的，因为这需要 JVM 和操作系统的参与。64位 JVM 默认线程栈是大小1 MB。这就是为什么说...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074255.html)

[java并发编程（十四）----(JUC原子类)对象的属性修改类型介绍](https://www.cnblogs.com/rickiyang/p/11074256.html)

摘要：今天我们介绍原子类的最后一个类型—-对象的属性修改类型: AtomicIntegerFieldUpdater,AtomicLongFieldUpdater,AtomicRefe...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074256.html)

[java并发编程（十三）----(JUC原子类)引用类型介绍（CAS和ABA的介绍）](https://www.cnblogs.com/rickiyang/p/11074257.html)

摘要：这一节我们将探讨引用类型原子类：AtomicReference, AtomicStampedRerence, AtomicMarkableReference。AtomicRef...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074257.html)

[java并发编程（十二）----(JUC原子类)数组类型介绍](https://www.cnblogs.com/rickiyang/p/11074258.html)

摘要：上一节我们介绍过三个基本类型的原子类，这次我们来看一下数组类型： AtomicIntegerArray, AtomicLongArray, AtomicReferenceArr...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074258.html)

[java并发编程（十一）----(JUC原子类)基本类型介绍](https://www.cnblogs.com/rickiyang/p/11074259.html)

摘要：上一节我们说到了基本原子类的简单介绍，这一节我们先来看一下基本类型: AtomicInteger, AtomicLong, AtomicBoolean。AtomicIntege...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074259.html)

[java并发编程（十）----JUC原子类介绍](https://www.cnblogs.com/rickiyang/p/11074260.html)

摘要：今天我们来看一下JUC包中的原子类，所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074260.html)

[java并发编程（九）----(JUC)CyclicBarrier](https://www.cnblogs.com/rickiyang/p/11074261.html)

摘要：上一篇我们介绍了CountDownlatch，我们知道CountDownlatch是“在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待”，即CountDow...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074261.html)

[java并发编程（八）----(JUC)CountDownLatch](https://www.cnblogs.com/rickiyang/p/11074262.html)

摘要：CountDownLatch 是一个非常实用的多线程控制工具类。” Count Down ” 在英文中意为倒计数， Latch 为门问的意思。如果翻译成为倒计数门阀， 我想大家...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074262.html)

[java并发编程（七）----（JUC）ReadWriteLock](https://www.cnblogs.com/rickiyang/p/11074263.html)

摘要：前面我们已经分析过JUC包里面的Lock锁，ReentrantLock锁和semaphore信号量机制。Lock锁实现了比synchronized更灵活的锁机制，Reentra...[阅读全文](https://www.cnblogs.com/rickiyang/p/11074263.html)




## 参考文章
* https://www.cnblogs.com/bjlhx/category/1086008.html
* https://segmentfault.com/a/1190000015558984
* https://segmentfault.com/u/ressmix
* https://www.cnblogs.com/AliCoder/p/11838532.html
* https://www.cnblogs.com/mtcarpenter/category/1851392.html
* https://www.cnblogs.com/rickiyang/category/1487709.html